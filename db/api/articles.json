[{
  "id": "1",
  "author": "qixin",
  "title": "1-setState 之后发生了什么 —— 浅谈 React 中的 Transaction",
  "description": "本文系对 深入理解 React 的 batchUpdate 机制 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。 之前在我的博客里有[...]",
  
  "pathName": "what-will-happen-after-setState-invoking-1",
  "tags": [
    "服务端渲染",
    "webpack",
    "vue",
    "性能调优",
    "Node.js",
    "express.js",
    "ES6 Module",
    "按需分块加载"
  ],
  "updatedAt": "2017-05-19 21:26:34",
  "createdAt": "2017-04-04 11:34:28",
  "toc": "<p><strong>文章目录</strong></p>\n<ul>\n<li><a href=\"#背景\">背景</a></li>\n<li><a href=\"#demo\">Demo</a></li>\n<li><a href=\"#流程\">流程</a></li>\n<li><a href=\"#服务器启动时将所有分块文件读进内存\">服务器启动时将所有分块文件读进内存</a></li>\n<li><a href=\"#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称\">首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></li>\n<li><a href=\"#根据名称获取内容后，拼好html写回response\">根据名称获取内容后，拼好HTML写回response</a><ul>\n<li><a href=\"#修改server-entry.js\">修改server-entry.js</a></li>\n<li><a href=\"#修改renderstream的end事件\">修改renderStream的end事件</a></li>\n</ul>\n</li>\n<li><a href=\"#在客户端手动做合并分块的操作\">在客户端手动做合并分块的操作</a><ul>\n<li><a href=\"#延迟app根实例的产生\">延迟app根实例的产生</a><ul>\n<li><a href=\"#在服务端生成根实例\">在服务端生成根实例</a></li>\n<li><a href=\"#延迟客户端根实例的产生与挂载\">延迟客户端根实例的产生与挂载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#简单修改异步组件\">简单修改异步组件</a><ul>\n<li><a href=\"#修改全局状态\">修改全局状态</a></li>\n<li><a href=\"#对应修改异步组件\">对应修改异步组件</a></li>\n<li><a href=\"#选择性优化客户端的router钩子\">选择性优化客户端的router钩子</a><ul>\n<li><a href=\"#router.aftereach\">router.afterEach</a></li>\n<li><a href=\"#router.beforeeach\">router.beforeEach</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#结语\">结语</a></li>\n</ul>\n",
  "html": "<p>本文介绍一种SSR与按需分块加载的首屏优化策略，可以达到将所有路由全部按需分块加载，并且完全不影响首屏速度的效果。</p>\n<h1><a href='#背景' id='背景' class='anchor'></a><a href='#背景'>背景</a></h1><p>SSR与按需分块加载，博主最初使用下来感觉其实意义有限</p>\n<p>假如全部路由都使用按需分块加载，那么首屏时间很可能不降反增，因为首屏对应的组件也同样要在客户端通过jsonp生成async script标签并异步获得。生成的标签如下：</p>\n<pre class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/dist/4.5e0b0c5a53f9c9a9cbfd.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这会严重影响首屏加载速度。</p>\n<p>假如又只有一小部分不常被访问的路由需要使用按需分块加载，那么能节省的代码量可能非常小，以博客为例，vue全家桶加一些其他的依赖占了几乎80%的体积</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.10</span>@vue: <span class=\"hljs-number\">157.97</span> KB (<span class=\"hljs-number\">39.3</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span>@vue-router: <span class=\"hljs-number\">54.82</span> KB (<span class=\"hljs-number\">13.6</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.15</span><span class=\"hljs-number\">.3</span>@axios: <span class=\"hljs-number\">35.04</span> KB (<span class=\"hljs-number\">8.72</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.5</span><span class=\"hljs-number\">.3</span>@vue-meta: <span class=\"hljs-number\">29.31</span> KB (<span class=\"hljs-number\">7.29</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>@vuex: <span class=\"hljs-number\">20.49</span> KB (<span class=\"hljs-number\">5.10</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vue-style-loader: <span class=\"hljs-number\">6.79</span> KB (<span class=\"hljs-number\">1.69</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.11</span><span class=\"hljs-number\">.9</span>@process: <span class=\"hljs-number\">5.17</span> KB (<span class=\"hljs-number\">1.29</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.25</span><span class=\"hljs-number\">.0</span>@css-loader: <span class=\"hljs-number\">1.47</span> KB (<span class=\"hljs-number\">0.366</span>%)\n<span class=\"hljs-number\">.10</span><span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span>@vue-loader: <span class=\"hljs-number\">1.09</span> KB (<span class=\"hljs-number\">0.271</span>%)\n<span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vuex-router-sync: <span class=\"hljs-number\">981</span> B (<span class=\"hljs-number\">0.238</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span>@webpack: <span class=\"hljs-number\">509</span> B (<span class=\"hljs-number\">0.124</span>%)\n&lt;self&gt;: <span class=\"hljs-number\">88.29</span> KB (<span class=\"hljs-number\">22.0</span>%)\n</code></pre><p>除非SPA自身的代码超过1M，否则那分出去的一小部分路由就只有几十KB，效果堪称鸡肋。</p>\n<p>那么，有没有一个办法，既能让所有路由全部按需分块加载，并且完全不影响首屏速度的效果呢？</p>\n<p>答案是有的，本文就是介绍如何使用SSR的服务端，来达到这样的效果。</p>\n<p>博主称之为按需分块加载的首屏优化策略</p>\n<h1><a href='#demo' id='demo' class='anchor'></a><a href='#demo'>Demo</a></h1><p>目前，本博客的所有页面均使用了这种首屏优化策略，读者可以自行刷新页面，可以发现，没有任何异步标签被jsonp生成。</p>\n<p>实际上，所有路由都被分出去后，app.js从533KB降到了504KB（未gzip前），刚好减小了一个vue-meta的大小，博主之所有做这个优化的原因，也是因为使用了vue-meta后app.js增加的代码太多，希望能通过分块来减小打包大小。</p>\n<p>从结果来说，效果刚好达到博主的期望</p>\n<h1><a href='#流程' id='流程' class='anchor'></a><a href='#流程'>流程</a></h1><p>本文策略的流程如下</p>\n<ul>\n<li>服务器启动时将所有分块文件读进内存</li>\n<li>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</li>\n<li>根据名称获取内容后，直接和全局状态window.__INITIAL<em>STATE</em>一同写回response</li>\n<li>在客户端手动做合并分块的操作</li>\n<li>简单修改异步组件</li>\n</ul>\n<p>由于开发环境做这种首屏优化意义相当小，因为前端工程师开发时关注的并不是加载速度，所以这也是一个正式环境下独享的一种优化策略。</p>\n<h1><a href='#服务器启动时将所有分块文件读进内存' id='服务器启动时将所有分块文件读进内存' class='anchor'></a><a href='#服务器启动时将所有分块文件读进内存'>服务器启动时将所有分块文件读进内存</a></h1><p>这里判定名称数组长度为3的是分块文件，依据是本博客webpack打包时加入了hash值，格式为<code>name.[hash].js</code>。<br>如果读者没有加入hash，自行修改数组长度为2即可。</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">const</span> chunkObj = {}\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  <span class=\"hljs-keyword\">const</span> fileArr = fs.readdirSync(<span class=\"hljs-string\">'./dist'</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = fileArr.length; i &lt; len; i++) {\n    <span class=\"hljs-keyword\">const</span> fileName = fileArr[i]\n    <span class=\"hljs-keyword\">const</span> arr = fileName.split(<span class=\"hljs-string\">'.'</span>)\n    <span class=\"hljs-keyword\">if</span> (arr.length === <span class=\"hljs-number\">3</span> &amp;&amp; arr[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'app'</span>) {\n      <span class=\"hljs-keyword\">const</span> input = fs.readFileSync(<span class=\"hljs-string\">`./dist/<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">'utf-8'</span>)\n      chunkObj[fileName] = input\n    }\n  }\n}\n</code></pre>\n<h1><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' id='首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' class='anchor'></a><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称'>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></h1><p>这一步是如果不知道分块命名的话是非常难的，原因在于，System.import导入的多个异步组件时，他们的导入顺序是无序的，因为都是ES6 Module异步导入，至少博主没有发现这个顺序有算出来的办法。</p>\n<p>另外，异步组件只能在客户端中拿到分块的名称，此时导入异步组件的函数如下：</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> __webpack_require__.e<span class=\"hljs-comment\">/* import() */</span>(<span class=\"hljs-number\">4</span>).then(__webpack_require__.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">51</span>));\n}\n</code></pre>\n<p>可以使用webpack命名分块的功能来实现这一点, 我专门列了<a href=\"https://smallpath.me/post/webpack-on-demand-chunk-name\">一篇文章</a></p>\n<p>在上面这个链接的情况下, 需要定义好分块的名称</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!process.BROWSER) {\n  Post<span class=\"hljs-selector-class\">.chunkName</span> = Page<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'CreatePostView'</span>\n  TagPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'TagPager'</span>\n  Tag<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Tag'</span>\n  BlogPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'BlogPager'</span>\n  Archive<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Archive'</span>\n}\n</code></pre><h1><a href='#根据名称获取内容后，拼好html写回response' id='根据名称获取内容后，拼好html写回response' class='anchor'></a><a href='#根据名称获取内容后，拼好html写回response'>根据名称获取内容后，拼好HTML写回response</a></h1><h2><a href='#修改server-entry.js' id='修改server-entry.js' class='anchor'></a><a href='#修改server-entry.js'>修改server-entry.js</a></h2><pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">return</span> Promise.all(router.getMatchedComponents().map(<span class=\"hljs-function\"><span class=\"hljs-params\">(component, index)</span> =&gt;</span> {\n    <span class=\"hljs-regexp\">//</span> 新增如下四句\n    const chunkName = component.chunkName\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> chunkName === <span class=\"hljs-string\">'string'</span>) {\n      context.chunkName = chunkName\n    }\n    <span class=\"hljs-keyword\">if</span> (component.preFetch) {\n      <span class=\"hljs-keyword\">return</span> component.preFetch(store, context).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n  })).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(arr)</span> =&gt;</span> {\n    isDev &amp;&amp; <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">data pre-fetch: ${<span class=\"hljs-built_in\">Date</span>.now() - s}ms</span>`)\n\n    context.initialState = store.state\n    <span class=\"hljs-keyword\">return</span> realApp\n  })\n</code></pre><h2><a href='#修改renderstream的end事件' id='修改renderstream的end事件' class='anchor'></a><a href='#修改renderstream的end事件'>修改renderStream的end事件</a></h2><pre class=\"hljs\"><code>    renderStream.<span class=\"hljs-keyword\">on</span>(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (context.initialState) {\n        <span class=\"hljs-keyword\">res</span>.<span class=\"hljs-keyword\">write</span>(\n          `<span class=\"hljs-symbol\">&lt;script&gt;</span>window.__INITIAL_STATE__=${\n          JSON.stringify(context.initialState)\n          }&lt;/script&gt;`\n        )\n      }\n\n      <span class=\"hljs-keyword\">let</span> tail = html.tail\n      <span class=\"hljs-keyword\">if</span> (isProd &amp;&amp; typeof context.chunkName === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key in chunkObj) {\n          <span class=\"hljs-keyword\">if</span> (key.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>] === context.chunkName) {\n            const chunk = `&lt;script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> charset=<span class=\"hljs-string\">\"utf-8\"</span>&gt;${chunkObj[key]}&lt;/script&gt;&lt;/body&gt;`\n            tail = tail.replace(<span class=\"hljs-string\">'&lt;/body&gt;'</span>, chunk)\n            <span class=\"hljs-keyword\">break</span>\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">res</span>.end(tail)\n      <span class=\"hljs-built_in\">log</span>.<span class=\"hljs-keyword\">debug</span>(`whole reques<span class=\"hljs-variable\">t:</span> ${Date.now() - s}ms`)\n    })\n</code></pre><h1><a href='#在客户端手动做合并分块的操作' id='在客户端手动做合并分块的操作' class='anchor'></a><a href='#在客户端手动做合并分块的操作'>在客户端手动做合并分块的操作</a></h1><p>这一步也是难点，相当坑，坑死人。</p>\n<p>博主的webpack配置中，由于要使用tree-shaking来省下20KB左右的打包大小，因此没有分vendor公共块出去。</p>\n<p>如果分了vendor，那么直接把上一步生成的script标签迁移到vendor块的script标签之后和app块的script标签之前，就可以保证在vue运行前执行了我们生成好的那个分块了。</p>\n<p>但是既然没有分块，所有代码都在app.js中，那么就需要延迟vue运行，以确保app.js标签后面的我们追加的script标签内容比vue先运行</p>\n<p>否则vue-router会提前发现该组件是异步组件，然后它就自己帮我们调用webpackJsonp生成好async script标签了，这本来就是本文要避免的。</p>\n<h2><a href='#延迟app根实例的产生' id='延迟app根实例的产生' class='anchor'></a><a href='#延迟app根实例的产生'>延迟app根实例的产生</a></h2><pre class=\"hljs\"><code>const <span class=\"hljs-attr\">isProd</span> = process.env.<span class=\"hljs-attr\">NODE_ENV</span> === 'production'\n\nconst <span class=\"hljs-attr\">appOption</span> = {\n  router,\n  store,\n  ...App\n}\n\n<span class=\"hljs-keyword\">let</span> app\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-attr\">isProd</span> === <span class=\"hljs-literal\">false</span>) {\n  <span class=\"hljs-attr\">app</span> = new Vue(appOption)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">preFetchComponent</span> = [\n  Sidebar\n]\n\nexport { app, appOption, router, store, preFetchComponent, isProd }\n</code></pre><h3><a href='#在服务端生成根实例' id='在服务端生成根实例' class='anchor'></a><a href='#在服务端生成根实例'>在服务端生成根实例</a></h3><p>本文和服务端入口文件没关系，直接生成</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, preFetchComponent, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> isDev = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n</code></pre><h3><a href='#延迟客户端根实例的产生与挂载' id='延迟客户端根实例的产生与挂载' class='anchor'></a><a href='#延迟客户端根实例的产生与挂载'>延迟客户端根实例的产生与挂载</a></h3><pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> callback = isProd ? setTimeout : router.onReady.bind(router)\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">true</span>\n}\n\ncallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isProd) store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n\n  <span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__.route.hash = <span class=\"hljs-built_in\">window</span>.location.hash\n  store.replaceState(<span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__)\n  realApp.$mount(<span class=\"hljs-string\">'#app'</span>)\n})\n</code></pre><p>router.onReady为vue-router 2.2.0的新增方法，在客户端异步组件加载完时触发，我们只在开发环境调用这个回调，用来确保客户端hydrate出来的HTML和SSR出来的一致。</p>\n<p>到了正式环境，直接用setTimeout来延迟加载了。</p>\n<h1><a href='#简单修改异步组件' id='简单修改异步组件' class='anchor'></a><a href='#简单修改异步组件'>简单修改异步组件</a></h1><h2><a href='#修改全局状态' id='修改全局状态' class='anchor'></a><a href='#修改全局状态'>修改全局状态</a></h2><p>添加如下的状态</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">isLoadingAsyncComponent:</span> <span class=\"hljs-literal\">false</span>\n</code></pre><h2><a href='#对应修改异步组件' id='对应修改异步组件' class='anchor'></a><a href='#对应修改异步组件'>对应修改异步组件</a></h2><pre class=\"hljs\"><code>  preFetch: fetchAchieves,\n  beforeMount () {\n    <span class=\"hljs-keyword\">this</span>.isLoadingAsyncComponent &amp;&amp; <span class=\"hljs-keyword\">this</span>.$root._isMounted &amp;&amp; fetchAchieves(<span class=\"hljs-keyword\">this</span>.$store, <span class=\"hljs-keyword\">this</span>.$route)\n  }\n</code></pre><p>不用这个状态来标志的话，客户端组件会在SSR数据已经存在的情况下再次获取组件，造成浪费</p>\n<h2><a href='#选择性优化客户端的router钩子' id='选择性优化客户端的router钩子' class='anchor'></a><a href='#选择性优化客户端的router钩子'>选择性优化客户端的router钩子</a></h2><p>如果你使用了router的两个钩子，建议做如下处理</p>\n<h3><a href='#router.aftereach' id='router.aftereach' class='anchor'></a><a href='#router.aftereach'>router.afterEach</a></h3><pre class=\"hljs\"><code>router.afterEach((<span class=\"hljs-keyword\">to</span>, <span class=\"hljs-keyword\">from</span>) =&gt; {\n  <span class=\"hljs-comment\">// should delay it to get the correct title generated by vue-meta</span>\n  <span class=\"hljs-keyword\">from</span>.<span class=\"hljs-built_in\">name</span> &amp;&amp; clientGoogleAnalyse(<span class=\"hljs-keyword\">to</span>.path)\n})\n</code></pre><p>通过本文的延迟app挂载这种方法时，router.afterEach会在初始时被vue-router触发，博主猜测应当是vue处理异步组件后自行触发的，因此需要一个标志来避免触发。</p>\n<p>由于本博客所有路由都是具名路由，而这种触发时from.name会为null，据此可以做过滤</p>\n<h3><a href='#router.beforeeach' id='router.beforeeach' class='anchor'></a><a href='#router.beforeeach'>router.beforeEach</a></h3><p>异步组件的存在，导致数据获取的流程发生了变化，首先是异步组件被加载好，再触发异步组件的preFetch钩子进行数据获取，最后根据数据是否正常判断是否该进入路由。</p>\n<p>如果不按这个流程来，会出现新路由数据尚未获取到就进入了该组件的情况，当数据拿到时会发生一次闪屏，不仅无法控制路由，而且用户体验非常差。</p>\n<p>读者可以参考如下的数据获取流程</p>\n<pre class=\"hljs\"><code>router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 仅hash变化时，直接进入路由</span>\n  <span class=\"hljs-keyword\">if</span> (to.path === <span class=\"hljs-keyword\">from</span>.path &amp;&amp; to.hash !== <span class=\"hljs-keyword\">from</span>.hash) {\n    <span class=\"hljs-keyword\">return</span> next()\n  }\n\n  <span class=\"hljs-comment\">// Loading组件开始加载</span>\n  <span class=\"hljs-keyword\">let</span> loadingPromise = store.dispatch(<span class=\"hljs-string\">'START_LOADING'</span>)\n  <span class=\"hljs-keyword\">let</span> endLoadingCallback = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> loadingPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">interval</span> =&gt;</span> {\n      clearInterval(interval)\n      store.dispatch(<span class=\"hljs-string\">'SET_PROGRESS'</span>, <span class=\"hljs-number\">100</span>)\n      next()\n    })\n  }\n\n  <span class=\"hljs-comment\">// 根据本博客的路由定义，一定有一个组件能够被匹配到</span>\n  <span class=\"hljs-keyword\">let</span> component = router.getMatchedComponents(to.fullPath)[<span class=\"hljs-number\">0</span>]\n\n  <span class=\"hljs-comment\">// 如果是一个异步组件，我们手动resolve它，再接着调用它的preFetch接口，这样可以避免闪屏</span>\n  <span class=\"hljs-comment\">// 异步组件也是一个函数，但是它没有options这个值，可以据此做条件判断</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> component === <span class=\"hljs-string\">'function'</span> &amp;&amp; !component.options) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 一个resolve函数</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">realComponent</span> =&gt;</span> {\n        resolve(realComponent)\n      }\n      <span class=\"hljs-comment\">// 对普通异步组件来说，它会在第一层中被直接resolve，因此直接将resolve函数传给它调用</span>\n      <span class=\"hljs-keyword\">let</span> res = component(_resolve)\n      <span class=\"hljs-comment\">// 对工厂模式的组件生成函数来说，它第一层中产生的只是工厂函数，组件是在第二步中产生的</span>\n      <span class=\"hljs-comment\">// 这种工厂函数是thenable的，因此将resolve函数用then传给第二层调用</span>\n      <span class=\"hljs-keyword\">if</span> (res &amp;&amp; res.then) {\n        res.then(_resolve)\n      }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">component</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的component就是异步组件加载完毕后的真实组件了，开始调用数据获取函数</span>\n      <span class=\"hljs-keyword\">return</span> letsGo(component, store, to, endLoadingCallback)\n    })\n  }\n  <span class=\"hljs-comment\">// 调用数据获取函数</span>\n  letsGo(component, store, to, endLoadingCallback)\n})\n\n<span class=\"hljs-comment\">// 数据获取函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letsGo</span> (<span class=\"hljs-params\">component, store, to, endLoadingCallback</span>) </span>{\n  <span class=\"hljs-comment\">// 如果preFetch钩子存在，调用这个钩子，并将endLoadingCallback这个停止loading并进入路由的回调传给它</span>\n  <span class=\"hljs-keyword\">if</span> (component &amp;&amp; component.preFetch) {\n    <span class=\"hljs-keyword\">return</span> component.preFetch(store, to, endLoadingCallback).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-built_in\">Date</span>.now().toLocaleString(), err)\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 如果preFetch钩子不存在，说明这是一个静态页面，直接导航进入。</span>\n    endLoadingCallback()\n  }\n}\n</code></pre><p>这里给出preFetch的模板</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-tag\">function</span> <span class=\"hljs-selector-tag\">preFetch</span> (store, { <span class=\"hljs-attribute\">path</span>: pathName, params, query }, <span class=\"hljs-selector-tag\">callback</span>) {\n  <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">store</span><span class=\"hljs-selector-class\">.dispatch</span>(<span class=\"hljs-string\">'FETCH_TAGS'</span>, {\n    <span class=\"hljs-attribute\">model</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attribute\">query</span>: {\n      <span class=\"hljs-attribute\">conditions</span>: {\n        <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'post'</span>,\n        <span class=\"hljs-attribute\">isPublic</span>: true\n      },\n      <span class=\"hljs-attribute\">select</span>: {\n        <span class=\"hljs-attribute\">_id</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attribute\">tags</span>: <span class=\"hljs-number\">1</span>\n      }\n    },\n    callback\n  })\n}\n</code></pre><p>这种模板既能让它在SSR中被调用，又可以在客户端中被路由权限控制调用，十分有用</p>\n<p>最后，在action中手动调用callback这个参数，即可停止loading并进入路由了</p>\n<h1><a href='#结语' id='结语' class='anchor'></a><a href='#结语'>结语</a></h1><p>本文介绍的这种所有路由全部按需分块加载并完全不影响首屏速度的策略，是首屏优化中极少有人关注的。</p>\n<p>然而，它的效果十分强大，按这种策略优化首屏之后，配合SSR的SPA可以任意扩展体积与功能，并且首屏渲染将和SPA只有首屏页面时几乎一模一样。例如，本博客现在就可以毫无顾忌地开始做搜索页面了。</p>\n<p>最后，非常明显的是，本文的策略会带来一个问题，即非首屏的访问速度将会被拖慢，因为需要浏览器自行发起jsonp请求。解决办法其实也比较简单，只需要在首屏加载完成后让浏览器自行请求并缓存好对应的分块即可，这要求我们在构建时就必须得知分块的路径，并且需要搭配一个超强的请求拦截器，这也正是博主下一篇文章的内容。</p>\n"
  },{
  "id": "2",
  "author": "qixin",
  "title": "2-setState 之后发生了什么 —— 浅谈 React 中的 Transaction",
  "description": "本文系对 深入理解 React 的 batchUpdate 机制 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。 之前在我的博客里有[...]",
  
  "pathName": "what-will-happen-after-setState-invoking-2",
  "tags": [
    "服务端渲染",
    "webpack",
    "vue",
    "性能调优",
    "Node.js",
    "express.js",
    "ES6 Module",
    "按需分块加载"
  ],
  "updatedAt": "2017-05-19 21:26:34",
  "createdAt": "2017-04-04 11:34:28",
  "toc": "<p><strong>文章目录</strong></p>\n<ul>\n<li><a href=\"#背景\">背景</a></li>\n<li><a href=\"#demo\">Demo</a></li>\n<li><a href=\"#流程\">流程</a></li>\n<li><a href=\"#服务器启动时将所有分块文件读进内存\">服务器启动时将所有分块文件读进内存</a></li>\n<li><a href=\"#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称\">首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></li>\n<li><a href=\"#根据名称获取内容后，拼好html写回response\">根据名称获取内容后，拼好HTML写回response</a><ul>\n<li><a href=\"#修改server-entry.js\">修改server-entry.js</a></li>\n<li><a href=\"#修改renderstream的end事件\">修改renderStream的end事件</a></li>\n</ul>\n</li>\n<li><a href=\"#在客户端手动做合并分块的操作\">在客户端手动做合并分块的操作</a><ul>\n<li><a href=\"#延迟app根实例的产生\">延迟app根实例的产生</a><ul>\n<li><a href=\"#在服务端生成根实例\">在服务端生成根实例</a></li>\n<li><a href=\"#延迟客户端根实例的产生与挂载\">延迟客户端根实例的产生与挂载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#简单修改异步组件\">简单修改异步组件</a><ul>\n<li><a href=\"#修改全局状态\">修改全局状态</a></li>\n<li><a href=\"#对应修改异步组件\">对应修改异步组件</a></li>\n<li><a href=\"#选择性优化客户端的router钩子\">选择性优化客户端的router钩子</a><ul>\n<li><a href=\"#router.aftereach\">router.afterEach</a></li>\n<li><a href=\"#router.beforeeach\">router.beforeEach</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#结语\">结语</a></li>\n</ul>\n",
  "html": "<p>本文介绍一种SSR与按需分块加载的首屏优化策略，可以达到将所有路由全部按需分块加载，并且完全不影响首屏速度的效果。</p>\n<h1><a href='#背景' id='背景' class='anchor'></a><a href='#背景'>背景</a></h1><p>SSR与按需分块加载，博主最初使用下来感觉其实意义有限</p>\n<p>假如全部路由都使用按需分块加载，那么首屏时间很可能不降反增，因为首屏对应的组件也同样要在客户端通过jsonp生成async script标签并异步获得。生成的标签如下：</p>\n<pre class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/dist/4.5e0b0c5a53f9c9a9cbfd.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这会严重影响首屏加载速度。</p>\n<p>假如又只有一小部分不常被访问的路由需要使用按需分块加载，那么能节省的代码量可能非常小，以博客为例，vue全家桶加一些其他的依赖占了几乎80%的体积</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.10</span>@vue: <span class=\"hljs-number\">157.97</span> KB (<span class=\"hljs-number\">39.3</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span>@vue-router: <span class=\"hljs-number\">54.82</span> KB (<span class=\"hljs-number\">13.6</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.15</span><span class=\"hljs-number\">.3</span>@axios: <span class=\"hljs-number\">35.04</span> KB (<span class=\"hljs-number\">8.72</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.5</span><span class=\"hljs-number\">.3</span>@vue-meta: <span class=\"hljs-number\">29.31</span> KB (<span class=\"hljs-number\">7.29</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>@vuex: <span class=\"hljs-number\">20.49</span> KB (<span class=\"hljs-number\">5.10</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vue-style-loader: <span class=\"hljs-number\">6.79</span> KB (<span class=\"hljs-number\">1.69</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.11</span><span class=\"hljs-number\">.9</span>@process: <span class=\"hljs-number\">5.17</span> KB (<span class=\"hljs-number\">1.29</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.25</span><span class=\"hljs-number\">.0</span>@css-loader: <span class=\"hljs-number\">1.47</span> KB (<span class=\"hljs-number\">0.366</span>%)\n<span class=\"hljs-number\">.10</span><span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span>@vue-loader: <span class=\"hljs-number\">1.09</span> KB (<span class=\"hljs-number\">0.271</span>%)\n<span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vuex-router-sync: <span class=\"hljs-number\">981</span> B (<span class=\"hljs-number\">0.238</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span>@webpack: <span class=\"hljs-number\">509</span> B (<span class=\"hljs-number\">0.124</span>%)\n&lt;self&gt;: <span class=\"hljs-number\">88.29</span> KB (<span class=\"hljs-number\">22.0</span>%)\n</code></pre><p>除非SPA自身的代码超过1M，否则那分出去的一小部分路由就只有几十KB，效果堪称鸡肋。</p>\n<p>那么，有没有一个办法，既能让所有路由全部按需分块加载，并且完全不影响首屏速度的效果呢？</p>\n<p>答案是有的，本文就是介绍如何使用SSR的服务端，来达到这样的效果。</p>\n<p>博主称之为按需分块加载的首屏优化策略</p>\n<h1><a href='#demo' id='demo' class='anchor'></a><a href='#demo'>Demo</a></h1><p>目前，本博客的所有页面均使用了这种首屏优化策略，读者可以自行刷新页面，可以发现，没有任何异步标签被jsonp生成。</p>\n<p>实际上，所有路由都被分出去后，app.js从533KB降到了504KB（未gzip前），刚好减小了一个vue-meta的大小，博主之所有做这个优化的原因，也是因为使用了vue-meta后app.js增加的代码太多，希望能通过分块来减小打包大小。</p>\n<p>从结果来说，效果刚好达到博主的期望</p>\n<h1><a href='#流程' id='流程' class='anchor'></a><a href='#流程'>流程</a></h1><p>本文策略的流程如下</p>\n<ul>\n<li>服务器启动时将所有分块文件读进内存</li>\n<li>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</li>\n<li>根据名称获取内容后，直接和全局状态window.__INITIAL<em>STATE</em>一同写回response</li>\n<li>在客户端手动做合并分块的操作</li>\n<li>简单修改异步组件</li>\n</ul>\n<p>由于开发环境做这种首屏优化意义相当小，因为前端工程师开发时关注的并不是加载速度，所以这也是一个正式环境下独享的一种优化策略。</p>\n<h1><a href='#服务器启动时将所有分块文件读进内存' id='服务器启动时将所有分块文件读进内存' class='anchor'></a><a href='#服务器启动时将所有分块文件读进内存'>服务器启动时将所有分块文件读进内存</a></h1><p>这里判定名称数组长度为3的是分块文件，依据是本博客webpack打包时加入了hash值，格式为<code>name.[hash].js</code>。<br>如果读者没有加入hash，自行修改数组长度为2即可。</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">const</span> chunkObj = {}\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  <span class=\"hljs-keyword\">const</span> fileArr = fs.readdirSync(<span class=\"hljs-string\">'./dist'</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = fileArr.length; i &lt; len; i++) {\n    <span class=\"hljs-keyword\">const</span> fileName = fileArr[i]\n    <span class=\"hljs-keyword\">const</span> arr = fileName.split(<span class=\"hljs-string\">'.'</span>)\n    <span class=\"hljs-keyword\">if</span> (arr.length === <span class=\"hljs-number\">3</span> &amp;&amp; arr[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'app'</span>) {\n      <span class=\"hljs-keyword\">const</span> input = fs.readFileSync(<span class=\"hljs-string\">`./dist/<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">'utf-8'</span>)\n      chunkObj[fileName] = input\n    }\n  }\n}\n</code></pre>\n<h1><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' id='首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' class='anchor'></a><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称'>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></h1><p>这一步是如果不知道分块命名的话是非常难的，原因在于，System.import导入的多个异步组件时，他们的导入顺序是无序的，因为都是ES6 Module异步导入，至少博主没有发现这个顺序有算出来的办法。</p>\n<p>另外，异步组件只能在客户端中拿到分块的名称，此时导入异步组件的函数如下：</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> __webpack_require__.e<span class=\"hljs-comment\">/* import() */</span>(<span class=\"hljs-number\">4</span>).then(__webpack_require__.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">51</span>));\n}\n</code></pre>\n<p>可以使用webpack命名分块的功能来实现这一点, 我专门列了<a href=\"https://smallpath.me/post/webpack-on-demand-chunk-name\">一篇文章</a></p>\n<p>在上面这个链接的情况下, 需要定义好分块的名称</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!process.BROWSER) {\n  Post<span class=\"hljs-selector-class\">.chunkName</span> = Page<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'CreatePostView'</span>\n  TagPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'TagPager'</span>\n  Tag<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Tag'</span>\n  BlogPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'BlogPager'</span>\n  Archive<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Archive'</span>\n}\n</code></pre><h1><a href='#根据名称获取内容后，拼好html写回response' id='根据名称获取内容后，拼好html写回response' class='anchor'></a><a href='#根据名称获取内容后，拼好html写回response'>根据名称获取内容后，拼好HTML写回response</a></h1><h2><a href='#修改server-entry.js' id='修改server-entry.js' class='anchor'></a><a href='#修改server-entry.js'>修改server-entry.js</a></h2><pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">return</span> Promise.all(router.getMatchedComponents().map(<span class=\"hljs-function\"><span class=\"hljs-params\">(component, index)</span> =&gt;</span> {\n    <span class=\"hljs-regexp\">//</span> 新增如下四句\n    const chunkName = component.chunkName\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> chunkName === <span class=\"hljs-string\">'string'</span>) {\n      context.chunkName = chunkName\n    }\n    <span class=\"hljs-keyword\">if</span> (component.preFetch) {\n      <span class=\"hljs-keyword\">return</span> component.preFetch(store, context).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n  })).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(arr)</span> =&gt;</span> {\n    isDev &amp;&amp; <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">data pre-fetch: ${<span class=\"hljs-built_in\">Date</span>.now() - s}ms</span>`)\n\n    context.initialState = store.state\n    <span class=\"hljs-keyword\">return</span> realApp\n  })\n</code></pre><h2><a href='#修改renderstream的end事件' id='修改renderstream的end事件' class='anchor'></a><a href='#修改renderstream的end事件'>修改renderStream的end事件</a></h2><pre class=\"hljs\"><code>    renderStream.<span class=\"hljs-keyword\">on</span>(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (context.initialState) {\n        <span class=\"hljs-keyword\">res</span>.<span class=\"hljs-keyword\">write</span>(\n          `<span class=\"hljs-symbol\">&lt;script&gt;</span>window.__INITIAL_STATE__=${\n          JSON.stringify(context.initialState)\n          }&lt;/script&gt;`\n        )\n      }\n\n      <span class=\"hljs-keyword\">let</span> tail = html.tail\n      <span class=\"hljs-keyword\">if</span> (isProd &amp;&amp; typeof context.chunkName === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key in chunkObj) {\n          <span class=\"hljs-keyword\">if</span> (key.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>] === context.chunkName) {\n            const chunk = `&lt;script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> charset=<span class=\"hljs-string\">\"utf-8\"</span>&gt;${chunkObj[key]}&lt;/script&gt;&lt;/body&gt;`\n            tail = tail.replace(<span class=\"hljs-string\">'&lt;/body&gt;'</span>, chunk)\n            <span class=\"hljs-keyword\">break</span>\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">res</span>.end(tail)\n      <span class=\"hljs-built_in\">log</span>.<span class=\"hljs-keyword\">debug</span>(`whole reques<span class=\"hljs-variable\">t:</span> ${Date.now() - s}ms`)\n    })\n</code></pre><h1><a href='#在客户端手动做合并分块的操作' id='在客户端手动做合并分块的操作' class='anchor'></a><a href='#在客户端手动做合并分块的操作'>在客户端手动做合并分块的操作</a></h1><p>这一步也是难点，相当坑，坑死人。</p>\n<p>博主的webpack配置中，由于要使用tree-shaking来省下20KB左右的打包大小，因此没有分vendor公共块出去。</p>\n<p>如果分了vendor，那么直接把上一步生成的script标签迁移到vendor块的script标签之后和app块的script标签之前，就可以保证在vue运行前执行了我们生成好的那个分块了。</p>\n<p>但是既然没有分块，所有代码都在app.js中，那么就需要延迟vue运行，以确保app.js标签后面的我们追加的script标签内容比vue先运行</p>\n<p>否则vue-router会提前发现该组件是异步组件，然后它就自己帮我们调用webpackJsonp生成好async script标签了，这本来就是本文要避免的。</p>\n<h2><a href='#延迟app根实例的产生' id='延迟app根实例的产生' class='anchor'></a><a href='#延迟app根实例的产生'>延迟app根实例的产生</a></h2><pre class=\"hljs\"><code>const <span class=\"hljs-attr\">isProd</span> = process.env.<span class=\"hljs-attr\">NODE_ENV</span> === 'production'\n\nconst <span class=\"hljs-attr\">appOption</span> = {\n  router,\n  store,\n  ...App\n}\n\n<span class=\"hljs-keyword\">let</span> app\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-attr\">isProd</span> === <span class=\"hljs-literal\">false</span>) {\n  <span class=\"hljs-attr\">app</span> = new Vue(appOption)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">preFetchComponent</span> = [\n  Sidebar\n]\n\nexport { app, appOption, router, store, preFetchComponent, isProd }\n</code></pre><h3><a href='#在服务端生成根实例' id='在服务端生成根实例' class='anchor'></a><a href='#在服务端生成根实例'>在服务端生成根实例</a></h3><p>本文和服务端入口文件没关系，直接生成</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, preFetchComponent, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> isDev = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n</code></pre><h3><a href='#延迟客户端根实例的产生与挂载' id='延迟客户端根实例的产生与挂载' class='anchor'></a><a href='#延迟客户端根实例的产生与挂载'>延迟客户端根实例的产生与挂载</a></h3><pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> callback = isProd ? setTimeout : router.onReady.bind(router)\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">true</span>\n}\n\ncallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isProd) store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n\n  <span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__.route.hash = <span class=\"hljs-built_in\">window</span>.location.hash\n  store.replaceState(<span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__)\n  realApp.$mount(<span class=\"hljs-string\">'#app'</span>)\n})\n</code></pre><p>router.onReady为vue-router 2.2.0的新增方法，在客户端异步组件加载完时触发，我们只在开发环境调用这个回调，用来确保客户端hydrate出来的HTML和SSR出来的一致。</p>\n<p>到了正式环境，直接用setTimeout来延迟加载了。</p>\n<h1><a href='#简单修改异步组件' id='简单修改异步组件' class='anchor'></a><a href='#简单修改异步组件'>简单修改异步组件</a></h1><h2><a href='#修改全局状态' id='修改全局状态' class='anchor'></a><a href='#修改全局状态'>修改全局状态</a></h2><p>添加如下的状态</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">isLoadingAsyncComponent:</span> <span class=\"hljs-literal\">false</span>\n</code></pre><h2><a href='#对应修改异步组件' id='对应修改异步组件' class='anchor'></a><a href='#对应修改异步组件'>对应修改异步组件</a></h2><pre class=\"hljs\"><code>  preFetch: fetchAchieves,\n  beforeMount () {\n    <span class=\"hljs-keyword\">this</span>.isLoadingAsyncComponent &amp;&amp; <span class=\"hljs-keyword\">this</span>.$root._isMounted &amp;&amp; fetchAchieves(<span class=\"hljs-keyword\">this</span>.$store, <span class=\"hljs-keyword\">this</span>.$route)\n  }\n</code></pre><p>不用这个状态来标志的话，客户端组件会在SSR数据已经存在的情况下再次获取组件，造成浪费</p>\n<h2><a href='#选择性优化客户端的router钩子' id='选择性优化客户端的router钩子' class='anchor'></a><a href='#选择性优化客户端的router钩子'>选择性优化客户端的router钩子</a></h2><p>如果你使用了router的两个钩子，建议做如下处理</p>\n<h3><a href='#router.aftereach' id='router.aftereach' class='anchor'></a><a href='#router.aftereach'>router.afterEach</a></h3><pre class=\"hljs\"><code>router.afterEach((<span class=\"hljs-keyword\">to</span>, <span class=\"hljs-keyword\">from</span>) =&gt; {\n  <span class=\"hljs-comment\">// should delay it to get the correct title generated by vue-meta</span>\n  <span class=\"hljs-keyword\">from</span>.<span class=\"hljs-built_in\">name</span> &amp;&amp; clientGoogleAnalyse(<span class=\"hljs-keyword\">to</span>.path)\n})\n</code></pre><p>通过本文的延迟app挂载这种方法时，router.afterEach会在初始时被vue-router触发，博主猜测应当是vue处理异步组件后自行触发的，因此需要一个标志来避免触发。</p>\n<p>由于本博客所有路由都是具名路由，而这种触发时from.name会为null，据此可以做过滤</p>\n<h3><a href='#router.beforeeach' id='router.beforeeach' class='anchor'></a><a href='#router.beforeeach'>router.beforeEach</a></h3><p>异步组件的存在，导致数据获取的流程发生了变化，首先是异步组件被加载好，再触发异步组件的preFetch钩子进行数据获取，最后根据数据是否正常判断是否该进入路由。</p>\n<p>如果不按这个流程来，会出现新路由数据尚未获取到就进入了该组件的情况，当数据拿到时会发生一次闪屏，不仅无法控制路由，而且用户体验非常差。</p>\n<p>读者可以参考如下的数据获取流程</p>\n<pre class=\"hljs\"><code>router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 仅hash变化时，直接进入路由</span>\n  <span class=\"hljs-keyword\">if</span> (to.path === <span class=\"hljs-keyword\">from</span>.path &amp;&amp; to.hash !== <span class=\"hljs-keyword\">from</span>.hash) {\n    <span class=\"hljs-keyword\">return</span> next()\n  }\n\n  <span class=\"hljs-comment\">// Loading组件开始加载</span>\n  <span class=\"hljs-keyword\">let</span> loadingPromise = store.dispatch(<span class=\"hljs-string\">'START_LOADING'</span>)\n  <span class=\"hljs-keyword\">let</span> endLoadingCallback = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> loadingPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">interval</span> =&gt;</span> {\n      clearInterval(interval)\n      store.dispatch(<span class=\"hljs-string\">'SET_PROGRESS'</span>, <span class=\"hljs-number\">100</span>)\n      next()\n    })\n  }\n\n  <span class=\"hljs-comment\">// 根据本博客的路由定义，一定有一个组件能够被匹配到</span>\n  <span class=\"hljs-keyword\">let</span> component = router.getMatchedComponents(to.fullPath)[<span class=\"hljs-number\">0</span>]\n\n  <span class=\"hljs-comment\">// 如果是一个异步组件，我们手动resolve它，再接着调用它的preFetch接口，这样可以避免闪屏</span>\n  <span class=\"hljs-comment\">// 异步组件也是一个函数，但是它没有options这个值，可以据此做条件判断</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> component === <span class=\"hljs-string\">'function'</span> &amp;&amp; !component.options) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 一个resolve函数</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">realComponent</span> =&gt;</span> {\n        resolve(realComponent)\n      }\n      <span class=\"hljs-comment\">// 对普通异步组件来说，它会在第一层中被直接resolve，因此直接将resolve函数传给它调用</span>\n      <span class=\"hljs-keyword\">let</span> res = component(_resolve)\n      <span class=\"hljs-comment\">// 对工厂模式的组件生成函数来说，它第一层中产生的只是工厂函数，组件是在第二步中产生的</span>\n      <span class=\"hljs-comment\">// 这种工厂函数是thenable的，因此将resolve函数用then传给第二层调用</span>\n      <span class=\"hljs-keyword\">if</span> (res &amp;&amp; res.then) {\n        res.then(_resolve)\n      }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">component</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的component就是异步组件加载完毕后的真实组件了，开始调用数据获取函数</span>\n      <span class=\"hljs-keyword\">return</span> letsGo(component, store, to, endLoadingCallback)\n    })\n  }\n  <span class=\"hljs-comment\">// 调用数据获取函数</span>\n  letsGo(component, store, to, endLoadingCallback)\n})\n\n<span class=\"hljs-comment\">// 数据获取函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letsGo</span> (<span class=\"hljs-params\">component, store, to, endLoadingCallback</span>) </span>{\n  <span class=\"hljs-comment\">// 如果preFetch钩子存在，调用这个钩子，并将endLoadingCallback这个停止loading并进入路由的回调传给它</span>\n  <span class=\"hljs-keyword\">if</span> (component &amp;&amp; component.preFetch) {\n    <span class=\"hljs-keyword\">return</span> component.preFetch(store, to, endLoadingCallback).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-built_in\">Date</span>.now().toLocaleString(), err)\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 如果preFetch钩子不存在，说明这是一个静态页面，直接导航进入。</span>\n    endLoadingCallback()\n  }\n}\n</code></pre><p>这里给出preFetch的模板</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-tag\">function</span> <span class=\"hljs-selector-tag\">preFetch</span> (store, { <span class=\"hljs-attribute\">path</span>: pathName, params, query }, <span class=\"hljs-selector-tag\">callback</span>) {\n  <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">store</span><span class=\"hljs-selector-class\">.dispatch</span>(<span class=\"hljs-string\">'FETCH_TAGS'</span>, {\n    <span class=\"hljs-attribute\">model</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attribute\">query</span>: {\n      <span class=\"hljs-attribute\">conditions</span>: {\n        <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'post'</span>,\n        <span class=\"hljs-attribute\">isPublic</span>: true\n      },\n      <span class=\"hljs-attribute\">select</span>: {\n        <span class=\"hljs-attribute\">_id</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attribute\">tags</span>: <span class=\"hljs-number\">1</span>\n      }\n    },\n    callback\n  })\n}\n</code></pre><p>这种模板既能让它在SSR中被调用，又可以在客户端中被路由权限控制调用，十分有用</p>\n<p>最后，在action中手动调用callback这个参数，即可停止loading并进入路由了</p>\n<h1><a href='#结语' id='结语' class='anchor'></a><a href='#结语'>结语</a></h1><p>本文介绍的这种所有路由全部按需分块加载并完全不影响首屏速度的策略，是首屏优化中极少有人关注的。</p>\n<p>然而，它的效果十分强大，按这种策略优化首屏之后，配合SSR的SPA可以任意扩展体积与功能，并且首屏渲染将和SPA只有首屏页面时几乎一模一样。例如，本博客现在就可以毫无顾忌地开始做搜索页面了。</p>\n<p>最后，非常明显的是，本文的策略会带来一个问题，即非首屏的访问速度将会被拖慢，因为需要浏览器自行发起jsonp请求。解决办法其实也比较简单，只需要在首屏加载完成后让浏览器自行请求并缓存好对应的分块即可，这要求我们在构建时就必须得知分块的路径，并且需要搭配一个超强的请求拦截器，这也正是博主下一篇文章的内容。</p>\n"
},{
  "id": "3",
  "author": "qixin",
  "title": "3-setState 之后发生了什么 —— 浅谈 React 中的 Transaction",
  "description": "本文系对 深入理解 React 的 batchUpdate 机制 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。 之前在我的博客里有[...]",

  "pathName": "what-will-happen-after-setState-invoking-3",
  "tags": [
    "服务端渲染",
    "webpack",
    "vue",
    "性能调优",
    "Node.js",
    "express.js",
    "ES6 Module",
    "按需分块加载"
  ],
  "updatedAt": "2017-05-19 21:26:34",
  "createdAt": "2017-04-04 11:34:28",
  "toc": "<p><strong>文章目录</strong></p>\n<ul>\n<li><a href=\"#背景\">背景</a></li>\n<li><a href=\"#demo\">Demo</a></li>\n<li><a href=\"#流程\">流程</a></li>\n<li><a href=\"#服务器启动时将所有分块文件读进内存\">服务器启动时将所有分块文件读进内存</a></li>\n<li><a href=\"#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称\">首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></li>\n<li><a href=\"#根据名称获取内容后，拼好html写回response\">根据名称获取内容后，拼好HTML写回response</a><ul>\n<li><a href=\"#修改server-entry.js\">修改server-entry.js</a></li>\n<li><a href=\"#修改renderstream的end事件\">修改renderStream的end事件</a></li>\n</ul>\n</li>\n<li><a href=\"#在客户端手动做合并分块的操作\">在客户端手动做合并分块的操作</a><ul>\n<li><a href=\"#延迟app根实例的产生\">延迟app根实例的产生</a><ul>\n<li><a href=\"#在服务端生成根实例\">在服务端生成根实例</a></li>\n<li><a href=\"#延迟客户端根实例的产生与挂载\">延迟客户端根实例的产生与挂载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#简单修改异步组件\">简单修改异步组件</a><ul>\n<li><a href=\"#修改全局状态\">修改全局状态</a></li>\n<li><a href=\"#对应修改异步组件\">对应修改异步组件</a></li>\n<li><a href=\"#选择性优化客户端的router钩子\">选择性优化客户端的router钩子</a><ul>\n<li><a href=\"#router.aftereach\">router.afterEach</a></li>\n<li><a href=\"#router.beforeeach\">router.beforeEach</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#结语\">结语</a></li>\n</ul>\n",
  "html": "<p>本文介绍一种SSR与按需分块加载的首屏优化策略，可以达到将所有路由全部按需分块加载，并且完全不影响首屏速度的效果。</p>\n<h1><a href='#背景' id='背景' class='anchor'></a><a href='#背景'>背景</a></h1><p>SSR与按需分块加载，博主最初使用下来感觉其实意义有限</p>\n<p>假如全部路由都使用按需分块加载，那么首屏时间很可能不降反增，因为首屏对应的组件也同样要在客户端通过jsonp生成async script标签并异步获得。生成的标签如下：</p>\n<pre class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/dist/4.5e0b0c5a53f9c9a9cbfd.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这会严重影响首屏加载速度。</p>\n<p>假如又只有一小部分不常被访问的路由需要使用按需分块加载，那么能节省的代码量可能非常小，以博客为例，vue全家桶加一些其他的依赖占了几乎80%的体积</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.10</span>@vue: <span class=\"hljs-number\">157.97</span> KB (<span class=\"hljs-number\">39.3</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span>@vue-router: <span class=\"hljs-number\">54.82</span> KB (<span class=\"hljs-number\">13.6</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.15</span><span class=\"hljs-number\">.3</span>@axios: <span class=\"hljs-number\">35.04</span> KB (<span class=\"hljs-number\">8.72</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.5</span><span class=\"hljs-number\">.3</span>@vue-meta: <span class=\"hljs-number\">29.31</span> KB (<span class=\"hljs-number\">7.29</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>@vuex: <span class=\"hljs-number\">20.49</span> KB (<span class=\"hljs-number\">5.10</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vue-style-loader: <span class=\"hljs-number\">6.79</span> KB (<span class=\"hljs-number\">1.69</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.11</span><span class=\"hljs-number\">.9</span>@process: <span class=\"hljs-number\">5.17</span> KB (<span class=\"hljs-number\">1.29</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.25</span><span class=\"hljs-number\">.0</span>@css-loader: <span class=\"hljs-number\">1.47</span> KB (<span class=\"hljs-number\">0.366</span>%)\n<span class=\"hljs-number\">.10</span><span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span>@vue-loader: <span class=\"hljs-number\">1.09</span> KB (<span class=\"hljs-number\">0.271</span>%)\n<span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vuex-router-sync: <span class=\"hljs-number\">981</span> B (<span class=\"hljs-number\">0.238</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span>@webpack: <span class=\"hljs-number\">509</span> B (<span class=\"hljs-number\">0.124</span>%)\n&lt;self&gt;: <span class=\"hljs-number\">88.29</span> KB (<span class=\"hljs-number\">22.0</span>%)\n</code></pre><p>除非SPA自身的代码超过1M，否则那分出去的一小部分路由就只有几十KB，效果堪称鸡肋。</p>\n<p>那么，有没有一个办法，既能让所有路由全部按需分块加载，并且完全不影响首屏速度的效果呢？</p>\n<p>答案是有的，本文就是介绍如何使用SSR的服务端，来达到这样的效果。</p>\n<p>博主称之为按需分块加载的首屏优化策略</p>\n<h1><a href='#demo' id='demo' class='anchor'></a><a href='#demo'>Demo</a></h1><p>目前，本博客的所有页面均使用了这种首屏优化策略，读者可以自行刷新页面，可以发现，没有任何异步标签被jsonp生成。</p>\n<p>实际上，所有路由都被分出去后，app.js从533KB降到了504KB（未gzip前），刚好减小了一个vue-meta的大小，博主之所有做这个优化的原因，也是因为使用了vue-meta后app.js增加的代码太多，希望能通过分块来减小打包大小。</p>\n<p>从结果来说，效果刚好达到博主的期望</p>\n<h1><a href='#流程' id='流程' class='anchor'></a><a href='#流程'>流程</a></h1><p>本文策略的流程如下</p>\n<ul>\n<li>服务器启动时将所有分块文件读进内存</li>\n<li>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</li>\n<li>根据名称获取内容后，直接和全局状态window.__INITIAL<em>STATE</em>一同写回response</li>\n<li>在客户端手动做合并分块的操作</li>\n<li>简单修改异步组件</li>\n</ul>\n<p>由于开发环境做这种首屏优化意义相当小，因为前端工程师开发时关注的并不是加载速度，所以这也是一个正式环境下独享的一种优化策略。</p>\n<h1><a href='#服务器启动时将所有分块文件读进内存' id='服务器启动时将所有分块文件读进内存' class='anchor'></a><a href='#服务器启动时将所有分块文件读进内存'>服务器启动时将所有分块文件读进内存</a></h1><p>这里判定名称数组长度为3的是分块文件，依据是本博客webpack打包时加入了hash值，格式为<code>name.[hash].js</code>。<br>如果读者没有加入hash，自行修改数组长度为2即可。</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">const</span> chunkObj = {}\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  <span class=\"hljs-keyword\">const</span> fileArr = fs.readdirSync(<span class=\"hljs-string\">'./dist'</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = fileArr.length; i &lt; len; i++) {\n    <span class=\"hljs-keyword\">const</span> fileName = fileArr[i]\n    <span class=\"hljs-keyword\">const</span> arr = fileName.split(<span class=\"hljs-string\">'.'</span>)\n    <span class=\"hljs-keyword\">if</span> (arr.length === <span class=\"hljs-number\">3</span> &amp;&amp; arr[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'app'</span>) {\n      <span class=\"hljs-keyword\">const</span> input = fs.readFileSync(<span class=\"hljs-string\">`./dist/<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">'utf-8'</span>)\n      chunkObj[fileName] = input\n    }\n  }\n}\n</code></pre>\n<h1><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' id='首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' class='anchor'></a><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称'>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></h1><p>这一步是如果不知道分块命名的话是非常难的，原因在于，System.import导入的多个异步组件时，他们的导入顺序是无序的，因为都是ES6 Module异步导入，至少博主没有发现这个顺序有算出来的办法。</p>\n<p>另外，异步组件只能在客户端中拿到分块的名称，此时导入异步组件的函数如下：</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> __webpack_require__.e<span class=\"hljs-comment\">/* import() */</span>(<span class=\"hljs-number\">4</span>).then(__webpack_require__.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">51</span>));\n}\n</code></pre>\n<p>可以使用webpack命名分块的功能来实现这一点, 我专门列了<a href=\"https://smallpath.me/post/webpack-on-demand-chunk-name\">一篇文章</a></p>\n<p>在上面这个链接的情况下, 需要定义好分块的名称</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!process.BROWSER) {\n  Post<span class=\"hljs-selector-class\">.chunkName</span> = Page<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'CreatePostView'</span>\n  TagPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'TagPager'</span>\n  Tag<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Tag'</span>\n  BlogPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'BlogPager'</span>\n  Archive<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Archive'</span>\n}\n</code></pre><h1><a href='#根据名称获取内容后，拼好html写回response' id='根据名称获取内容后，拼好html写回response' class='anchor'></a><a href='#根据名称获取内容后，拼好html写回response'>根据名称获取内容后，拼好HTML写回response</a></h1><h2><a href='#修改server-entry.js' id='修改server-entry.js' class='anchor'></a><a href='#修改server-entry.js'>修改server-entry.js</a></h2><pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">return</span> Promise.all(router.getMatchedComponents().map(<span class=\"hljs-function\"><span class=\"hljs-params\">(component, index)</span> =&gt;</span> {\n    <span class=\"hljs-regexp\">//</span> 新增如下四句\n    const chunkName = component.chunkName\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> chunkName === <span class=\"hljs-string\">'string'</span>) {\n      context.chunkName = chunkName\n    }\n    <span class=\"hljs-keyword\">if</span> (component.preFetch) {\n      <span class=\"hljs-keyword\">return</span> component.preFetch(store, context).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n  })).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(arr)</span> =&gt;</span> {\n    isDev &amp;&amp; <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">data pre-fetch: ${<span class=\"hljs-built_in\">Date</span>.now() - s}ms</span>`)\n\n    context.initialState = store.state\n    <span class=\"hljs-keyword\">return</span> realApp\n  })\n</code></pre><h2><a href='#修改renderstream的end事件' id='修改renderstream的end事件' class='anchor'></a><a href='#修改renderstream的end事件'>修改renderStream的end事件</a></h2><pre class=\"hljs\"><code>    renderStream.<span class=\"hljs-keyword\">on</span>(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (context.initialState) {\n        <span class=\"hljs-keyword\">res</span>.<span class=\"hljs-keyword\">write</span>(\n          `<span class=\"hljs-symbol\">&lt;script&gt;</span>window.__INITIAL_STATE__=${\n          JSON.stringify(context.initialState)\n          }&lt;/script&gt;`\n        )\n      }\n\n      <span class=\"hljs-keyword\">let</span> tail = html.tail\n      <span class=\"hljs-keyword\">if</span> (isProd &amp;&amp; typeof context.chunkName === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key in chunkObj) {\n          <span class=\"hljs-keyword\">if</span> (key.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>] === context.chunkName) {\n            const chunk = `&lt;script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> charset=<span class=\"hljs-string\">\"utf-8\"</span>&gt;${chunkObj[key]}&lt;/script&gt;&lt;/body&gt;`\n            tail = tail.replace(<span class=\"hljs-string\">'&lt;/body&gt;'</span>, chunk)\n            <span class=\"hljs-keyword\">break</span>\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">res</span>.end(tail)\n      <span class=\"hljs-built_in\">log</span>.<span class=\"hljs-keyword\">debug</span>(`whole reques<span class=\"hljs-variable\">t:</span> ${Date.now() - s}ms`)\n    })\n</code></pre><h1><a href='#在客户端手动做合并分块的操作' id='在客户端手动做合并分块的操作' class='anchor'></a><a href='#在客户端手动做合并分块的操作'>在客户端手动做合并分块的操作</a></h1><p>这一步也是难点，相当坑，坑死人。</p>\n<p>博主的webpack配置中，由于要使用tree-shaking来省下20KB左右的打包大小，因此没有分vendor公共块出去。</p>\n<p>如果分了vendor，那么直接把上一步生成的script标签迁移到vendor块的script标签之后和app块的script标签之前，就可以保证在vue运行前执行了我们生成好的那个分块了。</p>\n<p>但是既然没有分块，所有代码都在app.js中，那么就需要延迟vue运行，以确保app.js标签后面的我们追加的script标签内容比vue先运行</p>\n<p>否则vue-router会提前发现该组件是异步组件，然后它就自己帮我们调用webpackJsonp生成好async script标签了，这本来就是本文要避免的。</p>\n<h2><a href='#延迟app根实例的产生' id='延迟app根实例的产生' class='anchor'></a><a href='#延迟app根实例的产生'>延迟app根实例的产生</a></h2><pre class=\"hljs\"><code>const <span class=\"hljs-attr\">isProd</span> = process.env.<span class=\"hljs-attr\">NODE_ENV</span> === 'production'\n\nconst <span class=\"hljs-attr\">appOption</span> = {\n  router,\n  store,\n  ...App\n}\n\n<span class=\"hljs-keyword\">let</span> app\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-attr\">isProd</span> === <span class=\"hljs-literal\">false</span>) {\n  <span class=\"hljs-attr\">app</span> = new Vue(appOption)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">preFetchComponent</span> = [\n  Sidebar\n]\n\nexport { app, appOption, router, store, preFetchComponent, isProd }\n</code></pre><h3><a href='#在服务端生成根实例' id='在服务端生成根实例' class='anchor'></a><a href='#在服务端生成根实例'>在服务端生成根实例</a></h3><p>本文和服务端入口文件没关系，直接生成</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, preFetchComponent, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> isDev = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n</code></pre><h3><a href='#延迟客户端根实例的产生与挂载' id='延迟客户端根实例的产生与挂载' class='anchor'></a><a href='#延迟客户端根实例的产生与挂载'>延迟客户端根实例的产生与挂载</a></h3><pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> callback = isProd ? setTimeout : router.onReady.bind(router)\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">true</span>\n}\n\ncallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isProd) store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n\n  <span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__.route.hash = <span class=\"hljs-built_in\">window</span>.location.hash\n  store.replaceState(<span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__)\n  realApp.$mount(<span class=\"hljs-string\">'#app'</span>)\n})\n</code></pre><p>router.onReady为vue-router 2.2.0的新增方法，在客户端异步组件加载完时触发，我们只在开发环境调用这个回调，用来确保客户端hydrate出来的HTML和SSR出来的一致。</p>\n<p>到了正式环境，直接用setTimeout来延迟加载了。</p>\n<h1><a href='#简单修改异步组件' id='简单修改异步组件' class='anchor'></a><a href='#简单修改异步组件'>简单修改异步组件</a></h1><h2><a href='#修改全局状态' id='修改全局状态' class='anchor'></a><a href='#修改全局状态'>修改全局状态</a></h2><p>添加如下的状态</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">isLoadingAsyncComponent:</span> <span class=\"hljs-literal\">false</span>\n</code></pre><h2><a href='#对应修改异步组件' id='对应修改异步组件' class='anchor'></a><a href='#对应修改异步组件'>对应修改异步组件</a></h2><pre class=\"hljs\"><code>  preFetch: fetchAchieves,\n  beforeMount () {\n    <span class=\"hljs-keyword\">this</span>.isLoadingAsyncComponent &amp;&amp; <span class=\"hljs-keyword\">this</span>.$root._isMounted &amp;&amp; fetchAchieves(<span class=\"hljs-keyword\">this</span>.$store, <span class=\"hljs-keyword\">this</span>.$route)\n  }\n</code></pre><p>不用这个状态来标志的话，客户端组件会在SSR数据已经存在的情况下再次获取组件，造成浪费</p>\n<h2><a href='#选择性优化客户端的router钩子' id='选择性优化客户端的router钩子' class='anchor'></a><a href='#选择性优化客户端的router钩子'>选择性优化客户端的router钩子</a></h2><p>如果你使用了router的两个钩子，建议做如下处理</p>\n<h3><a href='#router.aftereach' id='router.aftereach' class='anchor'></a><a href='#router.aftereach'>router.afterEach</a></h3><pre class=\"hljs\"><code>router.afterEach((<span class=\"hljs-keyword\">to</span>, <span class=\"hljs-keyword\">from</span>) =&gt; {\n  <span class=\"hljs-comment\">// should delay it to get the correct title generated by vue-meta</span>\n  <span class=\"hljs-keyword\">from</span>.<span class=\"hljs-built_in\">name</span> &amp;&amp; clientGoogleAnalyse(<span class=\"hljs-keyword\">to</span>.path)\n})\n</code></pre><p>通过本文的延迟app挂载这种方法时，router.afterEach会在初始时被vue-router触发，博主猜测应当是vue处理异步组件后自行触发的，因此需要一个标志来避免触发。</p>\n<p>由于本博客所有路由都是具名路由，而这种触发时from.name会为null，据此可以做过滤</p>\n<h3><a href='#router.beforeeach' id='router.beforeeach' class='anchor'></a><a href='#router.beforeeach'>router.beforeEach</a></h3><p>异步组件的存在，导致数据获取的流程发生了变化，首先是异步组件被加载好，再触发异步组件的preFetch钩子进行数据获取，最后根据数据是否正常判断是否该进入路由。</p>\n<p>如果不按这个流程来，会出现新路由数据尚未获取到就进入了该组件的情况，当数据拿到时会发生一次闪屏，不仅无法控制路由，而且用户体验非常差。</p>\n<p>读者可以参考如下的数据获取流程</p>\n<pre class=\"hljs\"><code>router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 仅hash变化时，直接进入路由</span>\n  <span class=\"hljs-keyword\">if</span> (to.path === <span class=\"hljs-keyword\">from</span>.path &amp;&amp; to.hash !== <span class=\"hljs-keyword\">from</span>.hash) {\n    <span class=\"hljs-keyword\">return</span> next()\n  }\n\n  <span class=\"hljs-comment\">// Loading组件开始加载</span>\n  <span class=\"hljs-keyword\">let</span> loadingPromise = store.dispatch(<span class=\"hljs-string\">'START_LOADING'</span>)\n  <span class=\"hljs-keyword\">let</span> endLoadingCallback = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> loadingPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">interval</span> =&gt;</span> {\n      clearInterval(interval)\n      store.dispatch(<span class=\"hljs-string\">'SET_PROGRESS'</span>, <span class=\"hljs-number\">100</span>)\n      next()\n    })\n  }\n\n  <span class=\"hljs-comment\">// 根据本博客的路由定义，一定有一个组件能够被匹配到</span>\n  <span class=\"hljs-keyword\">let</span> component = router.getMatchedComponents(to.fullPath)[<span class=\"hljs-number\">0</span>]\n\n  <span class=\"hljs-comment\">// 如果是一个异步组件，我们手动resolve它，再接着调用它的preFetch接口，这样可以避免闪屏</span>\n  <span class=\"hljs-comment\">// 异步组件也是一个函数，但是它没有options这个值，可以据此做条件判断</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> component === <span class=\"hljs-string\">'function'</span> &amp;&amp; !component.options) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 一个resolve函数</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">realComponent</span> =&gt;</span> {\n        resolve(realComponent)\n      }\n      <span class=\"hljs-comment\">// 对普通异步组件来说，它会在第一层中被直接resolve，因此直接将resolve函数传给它调用</span>\n      <span class=\"hljs-keyword\">let</span> res = component(_resolve)\n      <span class=\"hljs-comment\">// 对工厂模式的组件生成函数来说，它第一层中产生的只是工厂函数，组件是在第二步中产生的</span>\n      <span class=\"hljs-comment\">// 这种工厂函数是thenable的，因此将resolve函数用then传给第二层调用</span>\n      <span class=\"hljs-keyword\">if</span> (res &amp;&amp; res.then) {\n        res.then(_resolve)\n      }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">component</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的component就是异步组件加载完毕后的真实组件了，开始调用数据获取函数</span>\n      <span class=\"hljs-keyword\">return</span> letsGo(component, store, to, endLoadingCallback)\n    })\n  }\n  <span class=\"hljs-comment\">// 调用数据获取函数</span>\n  letsGo(component, store, to, endLoadingCallback)\n})\n\n<span class=\"hljs-comment\">// 数据获取函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letsGo</span> (<span class=\"hljs-params\">component, store, to, endLoadingCallback</span>) </span>{\n  <span class=\"hljs-comment\">// 如果preFetch钩子存在，调用这个钩子，并将endLoadingCallback这个停止loading并进入路由的回调传给它</span>\n  <span class=\"hljs-keyword\">if</span> (component &amp;&amp; component.preFetch) {\n    <span class=\"hljs-keyword\">return</span> component.preFetch(store, to, endLoadingCallback).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-built_in\">Date</span>.now().toLocaleString(), err)\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 如果preFetch钩子不存在，说明这是一个静态页面，直接导航进入。</span>\n    endLoadingCallback()\n  }\n}\n</code></pre><p>这里给出preFetch的模板</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-tag\">function</span> <span class=\"hljs-selector-tag\">preFetch</span> (store, { <span class=\"hljs-attribute\">path</span>: pathName, params, query }, <span class=\"hljs-selector-tag\">callback</span>) {\n  <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">store</span><span class=\"hljs-selector-class\">.dispatch</span>(<span class=\"hljs-string\">'FETCH_TAGS'</span>, {\n    <span class=\"hljs-attribute\">model</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attribute\">query</span>: {\n      <span class=\"hljs-attribute\">conditions</span>: {\n        <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'post'</span>,\n        <span class=\"hljs-attribute\">isPublic</span>: true\n      },\n      <span class=\"hljs-attribute\">select</span>: {\n        <span class=\"hljs-attribute\">_id</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attribute\">tags</span>: <span class=\"hljs-number\">1</span>\n      }\n    },\n    callback\n  })\n}\n</code></pre><p>这种模板既能让它在SSR中被调用，又可以在客户端中被路由权限控制调用，十分有用</p>\n<p>最后，在action中手动调用callback这个参数，即可停止loading并进入路由了</p>\n<h1><a href='#结语' id='结语' class='anchor'></a><a href='#结语'>结语</a></h1><p>本文介绍的这种所有路由全部按需分块加载并完全不影响首屏速度的策略，是首屏优化中极少有人关注的。</p>\n<p>然而，它的效果十分强大，按这种策略优化首屏之后，配合SSR的SPA可以任意扩展体积与功能，并且首屏渲染将和SPA只有首屏页面时几乎一模一样。例如，本博客现在就可以毫无顾忌地开始做搜索页面了。</p>\n<p>最后，非常明显的是，本文的策略会带来一个问题，即非首屏的访问速度将会被拖慢，因为需要浏览器自行发起jsonp请求。解决办法其实也比较简单，只需要在首屏加载完成后让浏览器自行请求并缓存好对应的分块即可，这要求我们在构建时就必须得知分块的路径，并且需要搭配一个超强的请求拦截器，这也正是博主下一篇文章的内容。</p>\n"
},{
  "id": "4",
  "author": "qixin",
  "title": "4-setState 之后发生了什么 —— 浅谈 React 中的 Transaction",
  "description": "本文系对 深入理解 React 的 batchUpdate 机制 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。 之前在我的博客里有[...]",
  "pathName": "what-will-happen-after-setState-invoking-4",
  "tags": [
    "服务端渲染",
    "webpack",
    "vue",
    "性能调优",
    "Node.js",
    "express.js",
    "ES6 Module",
    "按需分块加载"
  ],
  "updatedAt": "2017-05-19 21:26:34",
  "createdAt": "2017-04-04 11:34:28",
  "toc": "<p><strong>文章目录</strong></p>\n<ul>\n<li><a href=\"#背景\">背景</a></li>\n<li><a href=\"#demo\">Demo</a></li>\n<li><a href=\"#流程\">流程</a></li>\n<li><a href=\"#服务器启动时将所有分块文件读进内存\">服务器启动时将所有分块文件读进内存</a></li>\n<li><a href=\"#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称\">首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></li>\n<li><a href=\"#根据名称获取内容后，拼好html写回response\">根据名称获取内容后，拼好HTML写回response</a><ul>\n<li><a href=\"#修改server-entry.js\">修改server-entry.js</a></li>\n<li><a href=\"#修改renderstream的end事件\">修改renderStream的end事件</a></li>\n</ul>\n</li>\n<li><a href=\"#在客户端手动做合并分块的操作\">在客户端手动做合并分块的操作</a><ul>\n<li><a href=\"#延迟app根实例的产生\">延迟app根实例的产生</a><ul>\n<li><a href=\"#在服务端生成根实例\">在服务端生成根实例</a></li>\n<li><a href=\"#延迟客户端根实例的产生与挂载\">延迟客户端根实例的产生与挂载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#简单修改异步组件\">简单修改异步组件</a><ul>\n<li><a href=\"#修改全局状态\">修改全局状态</a></li>\n<li><a href=\"#对应修改异步组件\">对应修改异步组件</a></li>\n<li><a href=\"#选择性优化客户端的router钩子\">选择性优化客户端的router钩子</a><ul>\n<li><a href=\"#router.aftereach\">router.afterEach</a></li>\n<li><a href=\"#router.beforeeach\">router.beforeEach</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#结语\">结语</a></li>\n</ul>\n",
  "html": "<p>本文介绍一种SSR与按需分块加载的首屏优化策略，可以达到将所有路由全部按需分块加载，并且完全不影响首屏速度的效果。</p>\n<h1><a href='#背景' id='背景' class='anchor'></a><a href='#背景'>背景</a></h1><p>SSR与按需分块加载，博主最初使用下来感觉其实意义有限</p>\n<p>假如全部路由都使用按需分块加载，那么首屏时间很可能不降反增，因为首屏对应的组件也同样要在客户端通过jsonp生成async script标签并异步获得。生成的标签如下：</p>\n<pre class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/dist/4.5e0b0c5a53f9c9a9cbfd.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这会严重影响首屏加载速度。</p>\n<p>假如又只有一小部分不常被访问的路由需要使用按需分块加载，那么能节省的代码量可能非常小，以博客为例，vue全家桶加一些其他的依赖占了几乎80%的体积</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.10</span>@vue: <span class=\"hljs-number\">157.97</span> KB (<span class=\"hljs-number\">39.3</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span>@vue-router: <span class=\"hljs-number\">54.82</span> KB (<span class=\"hljs-number\">13.6</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.15</span><span class=\"hljs-number\">.3</span>@axios: <span class=\"hljs-number\">35.04</span> KB (<span class=\"hljs-number\">8.72</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.5</span><span class=\"hljs-number\">.3</span>@vue-meta: <span class=\"hljs-number\">29.31</span> KB (<span class=\"hljs-number\">7.29</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>@vuex: <span class=\"hljs-number\">20.49</span> KB (<span class=\"hljs-number\">5.10</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vue-style-loader: <span class=\"hljs-number\">6.79</span> KB (<span class=\"hljs-number\">1.69</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.11</span><span class=\"hljs-number\">.9</span>@process: <span class=\"hljs-number\">5.17</span> KB (<span class=\"hljs-number\">1.29</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.25</span><span class=\"hljs-number\">.0</span>@css-loader: <span class=\"hljs-number\">1.47</span> KB (<span class=\"hljs-number\">0.366</span>%)\n<span class=\"hljs-number\">.10</span><span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span>@vue-loader: <span class=\"hljs-number\">1.09</span> KB (<span class=\"hljs-number\">0.271</span>%)\n<span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vuex-router-sync: <span class=\"hljs-number\">981</span> B (<span class=\"hljs-number\">0.238</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span>@webpack: <span class=\"hljs-number\">509</span> B (<span class=\"hljs-number\">0.124</span>%)\n&lt;self&gt;: <span class=\"hljs-number\">88.29</span> KB (<span class=\"hljs-number\">22.0</span>%)\n</code></pre><p>除非SPA自身的代码超过1M，否则那分出去的一小部分路由就只有几十KB，效果堪称鸡肋。</p>\n<p>那么，有没有一个办法，既能让所有路由全部按需分块加载，并且完全不影响首屏速度的效果呢？</p>\n<p>答案是有的，本文就是介绍如何使用SSR的服务端，来达到这样的效果。</p>\n<p>博主称之为按需分块加载的首屏优化策略</p>\n<h1><a href='#demo' id='demo' class='anchor'></a><a href='#demo'>Demo</a></h1><p>目前，本博客的所有页面均使用了这种首屏优化策略，读者可以自行刷新页面，可以发现，没有任何异步标签被jsonp生成。</p>\n<p>实际上，所有路由都被分出去后，app.js从533KB降到了504KB（未gzip前），刚好减小了一个vue-meta的大小，博主之所有做这个优化的原因，也是因为使用了vue-meta后app.js增加的代码太多，希望能通过分块来减小打包大小。</p>\n<p>从结果来说，效果刚好达到博主的期望</p>\n<h1><a href='#流程' id='流程' class='anchor'></a><a href='#流程'>流程</a></h1><p>本文策略的流程如下</p>\n<ul>\n<li>服务器启动时将所有分块文件读进内存</li>\n<li>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</li>\n<li>根据名称获取内容后，直接和全局状态window.__INITIAL<em>STATE</em>一同写回response</li>\n<li>在客户端手动做合并分块的操作</li>\n<li>简单修改异步组件</li>\n</ul>\n<p>由于开发环境做这种首屏优化意义相当小，因为前端工程师开发时关注的并不是加载速度，所以这也是一个正式环境下独享的一种优化策略。</p>\n<h1><a href='#服务器启动时将所有分块文件读进内存' id='服务器启动时将所有分块文件读进内存' class='anchor'></a><a href='#服务器启动时将所有分块文件读进内存'>服务器启动时将所有分块文件读进内存</a></h1><p>这里判定名称数组长度为3的是分块文件，依据是本博客webpack打包时加入了hash值，格式为<code>name.[hash].js</code>。<br>如果读者没有加入hash，自行修改数组长度为2即可。</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">const</span> chunkObj = {}\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  <span class=\"hljs-keyword\">const</span> fileArr = fs.readdirSync(<span class=\"hljs-string\">'./dist'</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = fileArr.length; i &lt; len; i++) {\n    <span class=\"hljs-keyword\">const</span> fileName = fileArr[i]\n    <span class=\"hljs-keyword\">const</span> arr = fileName.split(<span class=\"hljs-string\">'.'</span>)\n    <span class=\"hljs-keyword\">if</span> (arr.length === <span class=\"hljs-number\">3</span> &amp;&amp; arr[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'app'</span>) {\n      <span class=\"hljs-keyword\">const</span> input = fs.readFileSync(<span class=\"hljs-string\">`./dist/<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">'utf-8'</span>)\n      chunkObj[fileName] = input\n    }\n  }\n}\n</code></pre>\n<h1><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' id='首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' class='anchor'></a><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称'>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></h1><p>这一步是如果不知道分块命名的话是非常难的，原因在于，System.import导入的多个异步组件时，他们的导入顺序是无序的，因为都是ES6 Module异步导入，至少博主没有发现这个顺序有算出来的办法。</p>\n<p>另外，异步组件只能在客户端中拿到分块的名称，此时导入异步组件的函数如下：</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> __webpack_require__.e<span class=\"hljs-comment\">/* import() */</span>(<span class=\"hljs-number\">4</span>).then(__webpack_require__.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">51</span>));\n}\n</code></pre>\n<p>可以使用webpack命名分块的功能来实现这一点, 我专门列了<a href=\"https://smallpath.me/post/webpack-on-demand-chunk-name\">一篇文章</a></p>\n<p>在上面这个链接的情况下, 需要定义好分块的名称</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!process.BROWSER) {\n  Post<span class=\"hljs-selector-class\">.chunkName</span> = Page<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'CreatePostView'</span>\n  TagPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'TagPager'</span>\n  Tag<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Tag'</span>\n  BlogPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'BlogPager'</span>\n  Archive<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Archive'</span>\n}\n</code></pre><h1><a href='#根据名称获取内容后，拼好html写回response' id='根据名称获取内容后，拼好html写回response' class='anchor'></a><a href='#根据名称获取内容后，拼好html写回response'>根据名称获取内容后，拼好HTML写回response</a></h1><h2><a href='#修改server-entry.js' id='修改server-entry.js' class='anchor'></a><a href='#修改server-entry.js'>修改server-entry.js</a></h2><pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">return</span> Promise.all(router.getMatchedComponents().map(<span class=\"hljs-function\"><span class=\"hljs-params\">(component, index)</span> =&gt;</span> {\n    <span class=\"hljs-regexp\">//</span> 新增如下四句\n    const chunkName = component.chunkName\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> chunkName === <span class=\"hljs-string\">'string'</span>) {\n      context.chunkName = chunkName\n    }\n    <span class=\"hljs-keyword\">if</span> (component.preFetch) {\n      <span class=\"hljs-keyword\">return</span> component.preFetch(store, context).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n  })).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(arr)</span> =&gt;</span> {\n    isDev &amp;&amp; <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">data pre-fetch: ${<span class=\"hljs-built_in\">Date</span>.now() - s}ms</span>`)\n\n    context.initialState = store.state\n    <span class=\"hljs-keyword\">return</span> realApp\n  })\n</code></pre><h2><a href='#修改renderstream的end事件' id='修改renderstream的end事件' class='anchor'></a><a href='#修改renderstream的end事件'>修改renderStream的end事件</a></h2><pre class=\"hljs\"><code>    renderStream.<span class=\"hljs-keyword\">on</span>(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (context.initialState) {\n        <span class=\"hljs-keyword\">res</span>.<span class=\"hljs-keyword\">write</span>(\n          `<span class=\"hljs-symbol\">&lt;script&gt;</span>window.__INITIAL_STATE__=${\n          JSON.stringify(context.initialState)\n          }&lt;/script&gt;`\n        )\n      }\n\n      <span class=\"hljs-keyword\">let</span> tail = html.tail\n      <span class=\"hljs-keyword\">if</span> (isProd &amp;&amp; typeof context.chunkName === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key in chunkObj) {\n          <span class=\"hljs-keyword\">if</span> (key.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>] === context.chunkName) {\n            const chunk = `&lt;script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> charset=<span class=\"hljs-string\">\"utf-8\"</span>&gt;${chunkObj[key]}&lt;/script&gt;&lt;/body&gt;`\n            tail = tail.replace(<span class=\"hljs-string\">'&lt;/body&gt;'</span>, chunk)\n            <span class=\"hljs-keyword\">break</span>\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">res</span>.end(tail)\n      <span class=\"hljs-built_in\">log</span>.<span class=\"hljs-keyword\">debug</span>(`whole reques<span class=\"hljs-variable\">t:</span> ${Date.now() - s}ms`)\n    })\n</code></pre><h1><a href='#在客户端手动做合并分块的操作' id='在客户端手动做合并分块的操作' class='anchor'></a><a href='#在客户端手动做合并分块的操作'>在客户端手动做合并分块的操作</a></h1><p>这一步也是难点，相当坑，坑死人。</p>\n<p>博主的webpack配置中，由于要使用tree-shaking来省下20KB左右的打包大小，因此没有分vendor公共块出去。</p>\n<p>如果分了vendor，那么直接把上一步生成的script标签迁移到vendor块的script标签之后和app块的script标签之前，就可以保证在vue运行前执行了我们生成好的那个分块了。</p>\n<p>但是既然没有分块，所有代码都在app.js中，那么就需要延迟vue运行，以确保app.js标签后面的我们追加的script标签内容比vue先运行</p>\n<p>否则vue-router会提前发现该组件是异步组件，然后它就自己帮我们调用webpackJsonp生成好async script标签了，这本来就是本文要避免的。</p>\n<h2><a href='#延迟app根实例的产生' id='延迟app根实例的产生' class='anchor'></a><a href='#延迟app根实例的产生'>延迟app根实例的产生</a></h2><pre class=\"hljs\"><code>const <span class=\"hljs-attr\">isProd</span> = process.env.<span class=\"hljs-attr\">NODE_ENV</span> === 'production'\n\nconst <span class=\"hljs-attr\">appOption</span> = {\n  router,\n  store,\n  ...App\n}\n\n<span class=\"hljs-keyword\">let</span> app\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-attr\">isProd</span> === <span class=\"hljs-literal\">false</span>) {\n  <span class=\"hljs-attr\">app</span> = new Vue(appOption)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">preFetchComponent</span> = [\n  Sidebar\n]\n\nexport { app, appOption, router, store, preFetchComponent, isProd }\n</code></pre><h3><a href='#在服务端生成根实例' id='在服务端生成根实例' class='anchor'></a><a href='#在服务端生成根实例'>在服务端生成根实例</a></h3><p>本文和服务端入口文件没关系，直接生成</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, preFetchComponent, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> isDev = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n</code></pre><h3><a href='#延迟客户端根实例的产生与挂载' id='延迟客户端根实例的产生与挂载' class='anchor'></a><a href='#延迟客户端根实例的产生与挂载'>延迟客户端根实例的产生与挂载</a></h3><pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> callback = isProd ? setTimeout : router.onReady.bind(router)\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">true</span>\n}\n\ncallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isProd) store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n\n  <span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__.route.hash = <span class=\"hljs-built_in\">window</span>.location.hash\n  store.replaceState(<span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__)\n  realApp.$mount(<span class=\"hljs-string\">'#app'</span>)\n})\n</code></pre><p>router.onReady为vue-router 2.2.0的新增方法，在客户端异步组件加载完时触发，我们只在开发环境调用这个回调，用来确保客户端hydrate出来的HTML和SSR出来的一致。</p>\n<p>到了正式环境，直接用setTimeout来延迟加载了。</p>\n<h1><a href='#简单修改异步组件' id='简单修改异步组件' class='anchor'></a><a href='#简单修改异步组件'>简单修改异步组件</a></h1><h2><a href='#修改全局状态' id='修改全局状态' class='anchor'></a><a href='#修改全局状态'>修改全局状态</a></h2><p>添加如下的状态</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">isLoadingAsyncComponent:</span> <span class=\"hljs-literal\">false</span>\n</code></pre><h2><a href='#对应修改异步组件' id='对应修改异步组件' class='anchor'></a><a href='#对应修改异步组件'>对应修改异步组件</a></h2><pre class=\"hljs\"><code>  preFetch: fetchAchieves,\n  beforeMount () {\n    <span class=\"hljs-keyword\">this</span>.isLoadingAsyncComponent &amp;&amp; <span class=\"hljs-keyword\">this</span>.$root._isMounted &amp;&amp; fetchAchieves(<span class=\"hljs-keyword\">this</span>.$store, <span class=\"hljs-keyword\">this</span>.$route)\n  }\n</code></pre><p>不用这个状态来标志的话，客户端组件会在SSR数据已经存在的情况下再次获取组件，造成浪费</p>\n<h2><a href='#选择性优化客户端的router钩子' id='选择性优化客户端的router钩子' class='anchor'></a><a href='#选择性优化客户端的router钩子'>选择性优化客户端的router钩子</a></h2><p>如果你使用了router的两个钩子，建议做如下处理</p>\n<h3><a href='#router.aftereach' id='router.aftereach' class='anchor'></a><a href='#router.aftereach'>router.afterEach</a></h3><pre class=\"hljs\"><code>router.afterEach((<span class=\"hljs-keyword\">to</span>, <span class=\"hljs-keyword\">from</span>) =&gt; {\n  <span class=\"hljs-comment\">// should delay it to get the correct title generated by vue-meta</span>\n  <span class=\"hljs-keyword\">from</span>.<span class=\"hljs-built_in\">name</span> &amp;&amp; clientGoogleAnalyse(<span class=\"hljs-keyword\">to</span>.path)\n})\n</code></pre><p>通过本文的延迟app挂载这种方法时，router.afterEach会在初始时被vue-router触发，博主猜测应当是vue处理异步组件后自行触发的，因此需要一个标志来避免触发。</p>\n<p>由于本博客所有路由都是具名路由，而这种触发时from.name会为null，据此可以做过滤</p>\n<h3><a href='#router.beforeeach' id='router.beforeeach' class='anchor'></a><a href='#router.beforeeach'>router.beforeEach</a></h3><p>异步组件的存在，导致数据获取的流程发生了变化，首先是异步组件被加载好，再触发异步组件的preFetch钩子进行数据获取，最后根据数据是否正常判断是否该进入路由。</p>\n<p>如果不按这个流程来，会出现新路由数据尚未获取到就进入了该组件的情况，当数据拿到时会发生一次闪屏，不仅无法控制路由，而且用户体验非常差。</p>\n<p>读者可以参考如下的数据获取流程</p>\n<pre class=\"hljs\"><code>router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 仅hash变化时，直接进入路由</span>\n  <span class=\"hljs-keyword\">if</span> (to.path === <span class=\"hljs-keyword\">from</span>.path &amp;&amp; to.hash !== <span class=\"hljs-keyword\">from</span>.hash) {\n    <span class=\"hljs-keyword\">return</span> next()\n  }\n\n  <span class=\"hljs-comment\">// Loading组件开始加载</span>\n  <span class=\"hljs-keyword\">let</span> loadingPromise = store.dispatch(<span class=\"hljs-string\">'START_LOADING'</span>)\n  <span class=\"hljs-keyword\">let</span> endLoadingCallback = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> loadingPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">interval</span> =&gt;</span> {\n      clearInterval(interval)\n      store.dispatch(<span class=\"hljs-string\">'SET_PROGRESS'</span>, <span class=\"hljs-number\">100</span>)\n      next()\n    })\n  }\n\n  <span class=\"hljs-comment\">// 根据本博客的路由定义，一定有一个组件能够被匹配到</span>\n  <span class=\"hljs-keyword\">let</span> component = router.getMatchedComponents(to.fullPath)[<span class=\"hljs-number\">0</span>]\n\n  <span class=\"hljs-comment\">// 如果是一个异步组件，我们手动resolve它，再接着调用它的preFetch接口，这样可以避免闪屏</span>\n  <span class=\"hljs-comment\">// 异步组件也是一个函数，但是它没有options这个值，可以据此做条件判断</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> component === <span class=\"hljs-string\">'function'</span> &amp;&amp; !component.options) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 一个resolve函数</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">realComponent</span> =&gt;</span> {\n        resolve(realComponent)\n      }\n      <span class=\"hljs-comment\">// 对普通异步组件来说，它会在第一层中被直接resolve，因此直接将resolve函数传给它调用</span>\n      <span class=\"hljs-keyword\">let</span> res = component(_resolve)\n      <span class=\"hljs-comment\">// 对工厂模式的组件生成函数来说，它第一层中产生的只是工厂函数，组件是在第二步中产生的</span>\n      <span class=\"hljs-comment\">// 这种工厂函数是thenable的，因此将resolve函数用then传给第二层调用</span>\n      <span class=\"hljs-keyword\">if</span> (res &amp;&amp; res.then) {\n        res.then(_resolve)\n      }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">component</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的component就是异步组件加载完毕后的真实组件了，开始调用数据获取函数</span>\n      <span class=\"hljs-keyword\">return</span> letsGo(component, store, to, endLoadingCallback)\n    })\n  }\n  <span class=\"hljs-comment\">// 调用数据获取函数</span>\n  letsGo(component, store, to, endLoadingCallback)\n})\n\n<span class=\"hljs-comment\">// 数据获取函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letsGo</span> (<span class=\"hljs-params\">component, store, to, endLoadingCallback</span>) </span>{\n  <span class=\"hljs-comment\">// 如果preFetch钩子存在，调用这个钩子，并将endLoadingCallback这个停止loading并进入路由的回调传给它</span>\n  <span class=\"hljs-keyword\">if</span> (component &amp;&amp; component.preFetch) {\n    <span class=\"hljs-keyword\">return</span> component.preFetch(store, to, endLoadingCallback).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-built_in\">Date</span>.now().toLocaleString(), err)\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 如果preFetch钩子不存在，说明这是一个静态页面，直接导航进入。</span>\n    endLoadingCallback()\n  }\n}\n</code></pre><p>这里给出preFetch的模板</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-tag\">function</span> <span class=\"hljs-selector-tag\">preFetch</span> (store, { <span class=\"hljs-attribute\">path</span>: pathName, params, query }, <span class=\"hljs-selector-tag\">callback</span>) {\n  <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">store</span><span class=\"hljs-selector-class\">.dispatch</span>(<span class=\"hljs-string\">'FETCH_TAGS'</span>, {\n    <span class=\"hljs-attribute\">model</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attribute\">query</span>: {\n      <span class=\"hljs-attribute\">conditions</span>: {\n        <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'post'</span>,\n        <span class=\"hljs-attribute\">isPublic</span>: true\n      },\n      <span class=\"hljs-attribute\">select</span>: {\n        <span class=\"hljs-attribute\">_id</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attribute\">tags</span>: <span class=\"hljs-number\">1</span>\n      }\n    },\n    callback\n  })\n}\n</code></pre><p>这种模板既能让它在SSR中被调用，又可以在客户端中被路由权限控制调用，十分有用</p>\n<p>最后，在action中手动调用callback这个参数，即可停止loading并进入路由了</p>\n<h1><a href='#结语' id='结语' class='anchor'></a><a href='#结语'>结语</a></h1><p>本文介绍的这种所有路由全部按需分块加载并完全不影响首屏速度的策略，是首屏优化中极少有人关注的。</p>\n<p>然而，它的效果十分强大，按这种策略优化首屏之后，配合SSR的SPA可以任意扩展体积与功能，并且首屏渲染将和SPA只有首屏页面时几乎一模一样。例如，本博客现在就可以毫无顾忌地开始做搜索页面了。</p>\n<p>最后，非常明显的是，本文的策略会带来一个问题，即非首屏的访问速度将会被拖慢，因为需要浏览器自行发起jsonp请求。解决办法其实也比较简单，只需要在首屏加载完成后让浏览器自行请求并缓存好对应的分块即可，这要求我们在构建时就必须得知分块的路径，并且需要搭配一个超强的请求拦截器，这也正是博主下一篇文章的内容。</p>\n"
},{
  "id": "5",
  "author": "qixin",
  "title": "5-setState 之后发生了什么 —— 浅谈 React 中的 Transaction",
  "description": "本文系对 深入理解 React 的 batchUpdate 机制 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。 之前在我的博客里有[...]",
  "pathName": "what-will-happen-after-setState-invoking-5",
  "tags": [
    "服务端渲染",
    "webpack",
    "vue",
    "性能调优",
    "Node.js",
    "express.js",
    "ES6 Module",
    "按需分块加载"
  ],
  "updatedAt": "2017-05-19 21:26:34",
  "createdAt": "2017-04-04 11:34:28",
  "toc": "<p><strong>文章目录</strong></p>\n<ul>\n<li><a href=\"#背景\">背景</a></li>\n<li><a href=\"#demo\">Demo</a></li>\n<li><a href=\"#流程\">流程</a></li>\n<li><a href=\"#服务器启动时将所有分块文件读进内存\">服务器启动时将所有分块文件读进内存</a></li>\n<li><a href=\"#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称\">首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></li>\n<li><a href=\"#根据名称获取内容后，拼好html写回response\">根据名称获取内容后，拼好HTML写回response</a><ul>\n<li><a href=\"#修改server-entry.js\">修改server-entry.js</a></li>\n<li><a href=\"#修改renderstream的end事件\">修改renderStream的end事件</a></li>\n</ul>\n</li>\n<li><a href=\"#在客户端手动做合并分块的操作\">在客户端手动做合并分块的操作</a><ul>\n<li><a href=\"#延迟app根实例的产生\">延迟app根实例的产生</a><ul>\n<li><a href=\"#在服务端生成根实例\">在服务端生成根实例</a></li>\n<li><a href=\"#延迟客户端根实例的产生与挂载\">延迟客户端根实例的产生与挂载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#简单修改异步组件\">简单修改异步组件</a><ul>\n<li><a href=\"#修改全局状态\">修改全局状态</a></li>\n<li><a href=\"#对应修改异步组件\">对应修改异步组件</a></li>\n<li><a href=\"#选择性优化客户端的router钩子\">选择性优化客户端的router钩子</a><ul>\n<li><a href=\"#router.aftereach\">router.afterEach</a></li>\n<li><a href=\"#router.beforeeach\">router.beforeEach</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#结语\">结语</a></li>\n</ul>\n",
  "html": "<p>本文介绍一种SSR与按需分块加载的首屏优化策略，可以达到将所有路由全部按需分块加载，并且完全不影响首屏速度的效果。</p>\n<h1><a href='#背景' id='背景' class='anchor'></a><a href='#背景'>背景</a></h1><p>SSR与按需分块加载，博主最初使用下来感觉其实意义有限</p>\n<p>假如全部路由都使用按需分块加载，那么首屏时间很可能不降反增，因为首屏对应的组件也同样要在客户端通过jsonp生成async script标签并异步获得。生成的标签如下：</p>\n<pre class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/dist/4.5e0b0c5a53f9c9a9cbfd.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这会严重影响首屏加载速度。</p>\n<p>假如又只有一小部分不常被访问的路由需要使用按需分块加载，那么能节省的代码量可能非常小，以博客为例，vue全家桶加一些其他的依赖占了几乎80%的体积</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.10</span>@vue: <span class=\"hljs-number\">157.97</span> KB (<span class=\"hljs-number\">39.3</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span>@vue-router: <span class=\"hljs-number\">54.82</span> KB (<span class=\"hljs-number\">13.6</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.15</span><span class=\"hljs-number\">.3</span>@axios: <span class=\"hljs-number\">35.04</span> KB (<span class=\"hljs-number\">8.72</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.5</span><span class=\"hljs-number\">.3</span>@vue-meta: <span class=\"hljs-number\">29.31</span> KB (<span class=\"hljs-number\">7.29</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>@vuex: <span class=\"hljs-number\">20.49</span> KB (<span class=\"hljs-number\">5.10</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vue-style-loader: <span class=\"hljs-number\">6.79</span> KB (<span class=\"hljs-number\">1.69</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.11</span><span class=\"hljs-number\">.9</span>@process: <span class=\"hljs-number\">5.17</span> KB (<span class=\"hljs-number\">1.29</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.25</span><span class=\"hljs-number\">.0</span>@css-loader: <span class=\"hljs-number\">1.47</span> KB (<span class=\"hljs-number\">0.366</span>%)\n<span class=\"hljs-number\">.10</span><span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span>@vue-loader: <span class=\"hljs-number\">1.09</span> KB (<span class=\"hljs-number\">0.271</span>%)\n<span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vuex-router-sync: <span class=\"hljs-number\">981</span> B (<span class=\"hljs-number\">0.238</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span>@webpack: <span class=\"hljs-number\">509</span> B (<span class=\"hljs-number\">0.124</span>%)\n&lt;self&gt;: <span class=\"hljs-number\">88.29</span> KB (<span class=\"hljs-number\">22.0</span>%)\n</code></pre><p>除非SPA自身的代码超过1M，否则那分出去的一小部分路由就只有几十KB，效果堪称鸡肋。</p>\n<p>那么，有没有一个办法，既能让所有路由全部按需分块加载，并且完全不影响首屏速度的效果呢？</p>\n<p>答案是有的，本文就是介绍如何使用SSR的服务端，来达到这样的效果。</p>\n<p>博主称之为按需分块加载的首屏优化策略</p>\n<h1><a href='#demo' id='demo' class='anchor'></a><a href='#demo'>Demo</a></h1><p>目前，本博客的所有页面均使用了这种首屏优化策略，读者可以自行刷新页面，可以发现，没有任何异步标签被jsonp生成。</p>\n<p>实际上，所有路由都被分出去后，app.js从533KB降到了504KB（未gzip前），刚好减小了一个vue-meta的大小，博主之所有做这个优化的原因，也是因为使用了vue-meta后app.js增加的代码太多，希望能通过分块来减小打包大小。</p>\n<p>从结果来说，效果刚好达到博主的期望</p>\n<h1><a href='#流程' id='流程' class='anchor'></a><a href='#流程'>流程</a></h1><p>本文策略的流程如下</p>\n<ul>\n<li>服务器启动时将所有分块文件读进内存</li>\n<li>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</li>\n<li>根据名称获取内容后，直接和全局状态window.__INITIAL<em>STATE</em>一同写回response</li>\n<li>在客户端手动做合并分块的操作</li>\n<li>简单修改异步组件</li>\n</ul>\n<p>由于开发环境做这种首屏优化意义相当小，因为前端工程师开发时关注的并不是加载速度，所以这也是一个正式环境下独享的一种优化策略。</p>\n<h1><a href='#服务器启动时将所有分块文件读进内存' id='服务器启动时将所有分块文件读进内存' class='anchor'></a><a href='#服务器启动时将所有分块文件读进内存'>服务器启动时将所有分块文件读进内存</a></h1><p>这里判定名称数组长度为3的是分块文件，依据是本博客webpack打包时加入了hash值，格式为<code>name.[hash].js</code>。<br>如果读者没有加入hash，自行修改数组长度为2即可。</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">const</span> chunkObj = {}\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  <span class=\"hljs-keyword\">const</span> fileArr = fs.readdirSync(<span class=\"hljs-string\">'./dist'</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = fileArr.length; i &lt; len; i++) {\n    <span class=\"hljs-keyword\">const</span> fileName = fileArr[i]\n    <span class=\"hljs-keyword\">const</span> arr = fileName.split(<span class=\"hljs-string\">'.'</span>)\n    <span class=\"hljs-keyword\">if</span> (arr.length === <span class=\"hljs-number\">3</span> &amp;&amp; arr[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'app'</span>) {\n      <span class=\"hljs-keyword\">const</span> input = fs.readFileSync(<span class=\"hljs-string\">`./dist/<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">'utf-8'</span>)\n      chunkObj[fileName] = input\n    }\n  }\n}\n</code></pre>\n<h1><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' id='首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' class='anchor'></a><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称'>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></h1><p>这一步是如果不知道分块命名的话是非常难的，原因在于，System.import导入的多个异步组件时，他们的导入顺序是无序的，因为都是ES6 Module异步导入，至少博主没有发现这个顺序有算出来的办法。</p>\n<p>另外，异步组件只能在客户端中拿到分块的名称，此时导入异步组件的函数如下：</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> __webpack_require__.e<span class=\"hljs-comment\">/* import() */</span>(<span class=\"hljs-number\">4</span>).then(__webpack_require__.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">51</span>));\n}\n</code></pre>\n<p>可以使用webpack命名分块的功能来实现这一点, 我专门列了<a href=\"https://smallpath.me/post/webpack-on-demand-chunk-name\">一篇文章</a></p>\n<p>在上面这个链接的情况下, 需要定义好分块的名称</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!process.BROWSER) {\n  Post<span class=\"hljs-selector-class\">.chunkName</span> = Page<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'CreatePostView'</span>\n  TagPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'TagPager'</span>\n  Tag<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Tag'</span>\n  BlogPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'BlogPager'</span>\n  Archive<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Archive'</span>\n}\n</code></pre><h1><a href='#根据名称获取内容后，拼好html写回response' id='根据名称获取内容后，拼好html写回response' class='anchor'></a><a href='#根据名称获取内容后，拼好html写回response'>根据名称获取内容后，拼好HTML写回response</a></h1><h2><a href='#修改server-entry.js' id='修改server-entry.js' class='anchor'></a><a href='#修改server-entry.js'>修改server-entry.js</a></h2><pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">return</span> Promise.all(router.getMatchedComponents().map(<span class=\"hljs-function\"><span class=\"hljs-params\">(component, index)</span> =&gt;</span> {\n    <span class=\"hljs-regexp\">//</span> 新增如下四句\n    const chunkName = component.chunkName\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> chunkName === <span class=\"hljs-string\">'string'</span>) {\n      context.chunkName = chunkName\n    }\n    <span class=\"hljs-keyword\">if</span> (component.preFetch) {\n      <span class=\"hljs-keyword\">return</span> component.preFetch(store, context).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n  })).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(arr)</span> =&gt;</span> {\n    isDev &amp;&amp; <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">data pre-fetch: ${<span class=\"hljs-built_in\">Date</span>.now() - s}ms</span>`)\n\n    context.initialState = store.state\n    <span class=\"hljs-keyword\">return</span> realApp\n  })\n</code></pre><h2><a href='#修改renderstream的end事件' id='修改renderstream的end事件' class='anchor'></a><a href='#修改renderstream的end事件'>修改renderStream的end事件</a></h2><pre class=\"hljs\"><code>    renderStream.<span class=\"hljs-keyword\">on</span>(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (context.initialState) {\n        <span class=\"hljs-keyword\">res</span>.<span class=\"hljs-keyword\">write</span>(\n          `<span class=\"hljs-symbol\">&lt;script&gt;</span>window.__INITIAL_STATE__=${\n          JSON.stringify(context.initialState)\n          }&lt;/script&gt;`\n        )\n      }\n\n      <span class=\"hljs-keyword\">let</span> tail = html.tail\n      <span class=\"hljs-keyword\">if</span> (isProd &amp;&amp; typeof context.chunkName === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key in chunkObj) {\n          <span class=\"hljs-keyword\">if</span> (key.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>] === context.chunkName) {\n            const chunk = `&lt;script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> charset=<span class=\"hljs-string\">\"utf-8\"</span>&gt;${chunkObj[key]}&lt;/script&gt;&lt;/body&gt;`\n            tail = tail.replace(<span class=\"hljs-string\">'&lt;/body&gt;'</span>, chunk)\n            <span class=\"hljs-keyword\">break</span>\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">res</span>.end(tail)\n      <span class=\"hljs-built_in\">log</span>.<span class=\"hljs-keyword\">debug</span>(`whole reques<span class=\"hljs-variable\">t:</span> ${Date.now() - s}ms`)\n    })\n</code></pre><h1><a href='#在客户端手动做合并分块的操作' id='在客户端手动做合并分块的操作' class='anchor'></a><a href='#在客户端手动做合并分块的操作'>在客户端手动做合并分块的操作</a></h1><p>这一步也是难点，相当坑，坑死人。</p>\n<p>博主的webpack配置中，由于要使用tree-shaking来省下20KB左右的打包大小，因此没有分vendor公共块出去。</p>\n<p>如果分了vendor，那么直接把上一步生成的script标签迁移到vendor块的script标签之后和app块的script标签之前，就可以保证在vue运行前执行了我们生成好的那个分块了。</p>\n<p>但是既然没有分块，所有代码都在app.js中，那么就需要延迟vue运行，以确保app.js标签后面的我们追加的script标签内容比vue先运行</p>\n<p>否则vue-router会提前发现该组件是异步组件，然后它就自己帮我们调用webpackJsonp生成好async script标签了，这本来就是本文要避免的。</p>\n<h2><a href='#延迟app根实例的产生' id='延迟app根实例的产生' class='anchor'></a><a href='#延迟app根实例的产生'>延迟app根实例的产生</a></h2><pre class=\"hljs\"><code>const <span class=\"hljs-attr\">isProd</span> = process.env.<span class=\"hljs-attr\">NODE_ENV</span> === 'production'\n\nconst <span class=\"hljs-attr\">appOption</span> = {\n  router,\n  store,\n  ...App\n}\n\n<span class=\"hljs-keyword\">let</span> app\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-attr\">isProd</span> === <span class=\"hljs-literal\">false</span>) {\n  <span class=\"hljs-attr\">app</span> = new Vue(appOption)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">preFetchComponent</span> = [\n  Sidebar\n]\n\nexport { app, appOption, router, store, preFetchComponent, isProd }\n</code></pre><h3><a href='#在服务端生成根实例' id='在服务端生成根实例' class='anchor'></a><a href='#在服务端生成根实例'>在服务端生成根实例</a></h3><p>本文和服务端入口文件没关系，直接生成</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, preFetchComponent, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> isDev = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n</code></pre><h3><a href='#延迟客户端根实例的产生与挂载' id='延迟客户端根实例的产生与挂载' class='anchor'></a><a href='#延迟客户端根实例的产生与挂载'>延迟客户端根实例的产生与挂载</a></h3><pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> callback = isProd ? setTimeout : router.onReady.bind(router)\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">true</span>\n}\n\ncallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isProd) store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n\n  <span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__.route.hash = <span class=\"hljs-built_in\">window</span>.location.hash\n  store.replaceState(<span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__)\n  realApp.$mount(<span class=\"hljs-string\">'#app'</span>)\n})\n</code></pre><p>router.onReady为vue-router 2.2.0的新增方法，在客户端异步组件加载完时触发，我们只在开发环境调用这个回调，用来确保客户端hydrate出来的HTML和SSR出来的一致。</p>\n<p>到了正式环境，直接用setTimeout来延迟加载了。</p>\n<h1><a href='#简单修改异步组件' id='简单修改异步组件' class='anchor'></a><a href='#简单修改异步组件'>简单修改异步组件</a></h1><h2><a href='#修改全局状态' id='修改全局状态' class='anchor'></a><a href='#修改全局状态'>修改全局状态</a></h2><p>添加如下的状态</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">isLoadingAsyncComponent:</span> <span class=\"hljs-literal\">false</span>\n</code></pre><h2><a href='#对应修改异步组件' id='对应修改异步组件' class='anchor'></a><a href='#对应修改异步组件'>对应修改异步组件</a></h2><pre class=\"hljs\"><code>  preFetch: fetchAchieves,\n  beforeMount () {\n    <span class=\"hljs-keyword\">this</span>.isLoadingAsyncComponent &amp;&amp; <span class=\"hljs-keyword\">this</span>.$root._isMounted &amp;&amp; fetchAchieves(<span class=\"hljs-keyword\">this</span>.$store, <span class=\"hljs-keyword\">this</span>.$route)\n  }\n</code></pre><p>不用这个状态来标志的话，客户端组件会在SSR数据已经存在的情况下再次获取组件，造成浪费</p>\n<h2><a href='#选择性优化客户端的router钩子' id='选择性优化客户端的router钩子' class='anchor'></a><a href='#选择性优化客户端的router钩子'>选择性优化客户端的router钩子</a></h2><p>如果你使用了router的两个钩子，建议做如下处理</p>\n<h3><a href='#router.aftereach' id='router.aftereach' class='anchor'></a><a href='#router.aftereach'>router.afterEach</a></h3><pre class=\"hljs\"><code>router.afterEach((<span class=\"hljs-keyword\">to</span>, <span class=\"hljs-keyword\">from</span>) =&gt; {\n  <span class=\"hljs-comment\">// should delay it to get the correct title generated by vue-meta</span>\n  <span class=\"hljs-keyword\">from</span>.<span class=\"hljs-built_in\">name</span> &amp;&amp; clientGoogleAnalyse(<span class=\"hljs-keyword\">to</span>.path)\n})\n</code></pre><p>通过本文的延迟app挂载这种方法时，router.afterEach会在初始时被vue-router触发，博主猜测应当是vue处理异步组件后自行触发的，因此需要一个标志来避免触发。</p>\n<p>由于本博客所有路由都是具名路由，而这种触发时from.name会为null，据此可以做过滤</p>\n<h3><a href='#router.beforeeach' id='router.beforeeach' class='anchor'></a><a href='#router.beforeeach'>router.beforeEach</a></h3><p>异步组件的存在，导致数据获取的流程发生了变化，首先是异步组件被加载好，再触发异步组件的preFetch钩子进行数据获取，最后根据数据是否正常判断是否该进入路由。</p>\n<p>如果不按这个流程来，会出现新路由数据尚未获取到就进入了该组件的情况，当数据拿到时会发生一次闪屏，不仅无法控制路由，而且用户体验非常差。</p>\n<p>读者可以参考如下的数据获取流程</p>\n<pre class=\"hljs\"><code>router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 仅hash变化时，直接进入路由</span>\n  <span class=\"hljs-keyword\">if</span> (to.path === <span class=\"hljs-keyword\">from</span>.path &amp;&amp; to.hash !== <span class=\"hljs-keyword\">from</span>.hash) {\n    <span class=\"hljs-keyword\">return</span> next()\n  }\n\n  <span class=\"hljs-comment\">// Loading组件开始加载</span>\n  <span class=\"hljs-keyword\">let</span> loadingPromise = store.dispatch(<span class=\"hljs-string\">'START_LOADING'</span>)\n  <span class=\"hljs-keyword\">let</span> endLoadingCallback = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> loadingPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">interval</span> =&gt;</span> {\n      clearInterval(interval)\n      store.dispatch(<span class=\"hljs-string\">'SET_PROGRESS'</span>, <span class=\"hljs-number\">100</span>)\n      next()\n    })\n  }\n\n  <span class=\"hljs-comment\">// 根据本博客的路由定义，一定有一个组件能够被匹配到</span>\n  <span class=\"hljs-keyword\">let</span> component = router.getMatchedComponents(to.fullPath)[<span class=\"hljs-number\">0</span>]\n\n  <span class=\"hljs-comment\">// 如果是一个异步组件，我们手动resolve它，再接着调用它的preFetch接口，这样可以避免闪屏</span>\n  <span class=\"hljs-comment\">// 异步组件也是一个函数，但是它没有options这个值，可以据此做条件判断</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> component === <span class=\"hljs-string\">'function'</span> &amp;&amp; !component.options) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 一个resolve函数</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">realComponent</span> =&gt;</span> {\n        resolve(realComponent)\n      }\n      <span class=\"hljs-comment\">// 对普通异步组件来说，它会在第一层中被直接resolve，因此直接将resolve函数传给它调用</span>\n      <span class=\"hljs-keyword\">let</span> res = component(_resolve)\n      <span class=\"hljs-comment\">// 对工厂模式的组件生成函数来说，它第一层中产生的只是工厂函数，组件是在第二步中产生的</span>\n      <span class=\"hljs-comment\">// 这种工厂函数是thenable的，因此将resolve函数用then传给第二层调用</span>\n      <span class=\"hljs-keyword\">if</span> (res &amp;&amp; res.then) {\n        res.then(_resolve)\n      }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">component</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的component就是异步组件加载完毕后的真实组件了，开始调用数据获取函数</span>\n      <span class=\"hljs-keyword\">return</span> letsGo(component, store, to, endLoadingCallback)\n    })\n  }\n  <span class=\"hljs-comment\">// 调用数据获取函数</span>\n  letsGo(component, store, to, endLoadingCallback)\n})\n\n<span class=\"hljs-comment\">// 数据获取函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letsGo</span> (<span class=\"hljs-params\">component, store, to, endLoadingCallback</span>) </span>{\n  <span class=\"hljs-comment\">// 如果preFetch钩子存在，调用这个钩子，并将endLoadingCallback这个停止loading并进入路由的回调传给它</span>\n  <span class=\"hljs-keyword\">if</span> (component &amp;&amp; component.preFetch) {\n    <span class=\"hljs-keyword\">return</span> component.preFetch(store, to, endLoadingCallback).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-built_in\">Date</span>.now().toLocaleString(), err)\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 如果preFetch钩子不存在，说明这是一个静态页面，直接导航进入。</span>\n    endLoadingCallback()\n  }\n}\n</code></pre><p>这里给出preFetch的模板</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-tag\">function</span> <span class=\"hljs-selector-tag\">preFetch</span> (store, { <span class=\"hljs-attribute\">path</span>: pathName, params, query }, <span class=\"hljs-selector-tag\">callback</span>) {\n  <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">store</span><span class=\"hljs-selector-class\">.dispatch</span>(<span class=\"hljs-string\">'FETCH_TAGS'</span>, {\n    <span class=\"hljs-attribute\">model</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attribute\">query</span>: {\n      <span class=\"hljs-attribute\">conditions</span>: {\n        <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'post'</span>,\n        <span class=\"hljs-attribute\">isPublic</span>: true\n      },\n      <span class=\"hljs-attribute\">select</span>: {\n        <span class=\"hljs-attribute\">_id</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attribute\">tags</span>: <span class=\"hljs-number\">1</span>\n      }\n    },\n    callback\n  })\n}\n</code></pre><p>这种模板既能让它在SSR中被调用，又可以在客户端中被路由权限控制调用，十分有用</p>\n<p>最后，在action中手动调用callback这个参数，即可停止loading并进入路由了</p>\n<h1><a href='#结语' id='结语' class='anchor'></a><a href='#结语'>结语</a></h1><p>本文介绍的这种所有路由全部按需分块加载并完全不影响首屏速度的策略，是首屏优化中极少有人关注的。</p>\n<p>然而，它的效果十分强大，按这种策略优化首屏之后，配合SSR的SPA可以任意扩展体积与功能，并且首屏渲染将和SPA只有首屏页面时几乎一模一样。例如，本博客现在就可以毫无顾忌地开始做搜索页面了。</p>\n<p>最后，非常明显的是，本文的策略会带来一个问题，即非首屏的访问速度将会被拖慢，因为需要浏览器自行发起jsonp请求。解决办法其实也比较简单，只需要在首屏加载完成后让浏览器自行请求并缓存好对应的分块即可，这要求我们在构建时就必须得知分块的路径，并且需要搭配一个超强的请求拦截器，这也正是博主下一篇文章的内容。</p>\n"
},{
  "id": "6",
  "author": "qixin",
  "title": "6-setState 之后发生了什么 —— 浅谈 React 中的 Transaction",
  "description": "本文系对 深入理解 React 的 batchUpdate 机制 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。 之前在我的博客里有[...]",
  "pathName": "what-will-happen-after-setState-invoking-6",
  "tags": [
    "服务端渲染",
    "webpack",
    "vue",
    "性能调优",
    "Node.js",
    "express.js",
    "ES6 Module",
    "按需分块加载"
  ],
  "updatedAt": "2017-05-19 21:26:34",
  "createdAt": "2017-04-04 11:34:28",
  "toc": "<p><strong>文章目录</strong></p>\n<ul>\n<li><a href=\"#背景\">背景</a></li>\n<li><a href=\"#demo\">Demo</a></li>\n<li><a href=\"#流程\">流程</a></li>\n<li><a href=\"#服务器启动时将所有分块文件读进内存\">服务器启动时将所有分块文件读进内存</a></li>\n<li><a href=\"#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称\">首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></li>\n<li><a href=\"#根据名称获取内容后，拼好html写回response\">根据名称获取内容后，拼好HTML写回response</a><ul>\n<li><a href=\"#修改server-entry.js\">修改server-entry.js</a></li>\n<li><a href=\"#修改renderstream的end事件\">修改renderStream的end事件</a></li>\n</ul>\n</li>\n<li><a href=\"#在客户端手动做合并分块的操作\">在客户端手动做合并分块的操作</a><ul>\n<li><a href=\"#延迟app根实例的产生\">延迟app根实例的产生</a><ul>\n<li><a href=\"#在服务端生成根实例\">在服务端生成根实例</a></li>\n<li><a href=\"#延迟客户端根实例的产生与挂载\">延迟客户端根实例的产生与挂载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#简单修改异步组件\">简单修改异步组件</a><ul>\n<li><a href=\"#修改全局状态\">修改全局状态</a></li>\n<li><a href=\"#对应修改异步组件\">对应修改异步组件</a></li>\n<li><a href=\"#选择性优化客户端的router钩子\">选择性优化客户端的router钩子</a><ul>\n<li><a href=\"#router.aftereach\">router.afterEach</a></li>\n<li><a href=\"#router.beforeeach\">router.beforeEach</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#结语\">结语</a></li>\n</ul>\n",
  "html": "<p>本文介绍一种SSR与按需分块加载的首屏优化策略，可以达到将所有路由全部按需分块加载，并且完全不影响首屏速度的效果。</p>\n<h1><a href='#背景' id='背景' class='anchor'></a><a href='#背景'>背景</a></h1><p>SSR与按需分块加载，博主最初使用下来感觉其实意义有限</p>\n<p>假如全部路由都使用按需分块加载，那么首屏时间很可能不降反增，因为首屏对应的组件也同样要在客户端通过jsonp生成async script标签并异步获得。生成的标签如下：</p>\n<pre class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/dist/4.5e0b0c5a53f9c9a9cbfd.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这会严重影响首屏加载速度。</p>\n<p>假如又只有一小部分不常被访问的路由需要使用按需分块加载，那么能节省的代码量可能非常小，以博客为例，vue全家桶加一些其他的依赖占了几乎80%的体积</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.10</span>@vue: <span class=\"hljs-number\">157.97</span> KB (<span class=\"hljs-number\">39.3</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span>@vue-router: <span class=\"hljs-number\">54.82</span> KB (<span class=\"hljs-number\">13.6</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.15</span><span class=\"hljs-number\">.3</span>@axios: <span class=\"hljs-number\">35.04</span> KB (<span class=\"hljs-number\">8.72</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.5</span><span class=\"hljs-number\">.3</span>@vue-meta: <span class=\"hljs-number\">29.31</span> KB (<span class=\"hljs-number\">7.29</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>@vuex: <span class=\"hljs-number\">20.49</span> KB (<span class=\"hljs-number\">5.10</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vue-style-loader: <span class=\"hljs-number\">6.79</span> KB (<span class=\"hljs-number\">1.69</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.11</span><span class=\"hljs-number\">.9</span>@process: <span class=\"hljs-number\">5.17</span> KB (<span class=\"hljs-number\">1.29</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.25</span><span class=\"hljs-number\">.0</span>@css-loader: <span class=\"hljs-number\">1.47</span> KB (<span class=\"hljs-number\">0.366</span>%)\n<span class=\"hljs-number\">.10</span><span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span>@vue-loader: <span class=\"hljs-number\">1.09</span> KB (<span class=\"hljs-number\">0.271</span>%)\n<span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vuex-router-sync: <span class=\"hljs-number\">981</span> B (<span class=\"hljs-number\">0.238</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span>@webpack: <span class=\"hljs-number\">509</span> B (<span class=\"hljs-number\">0.124</span>%)\n&lt;self&gt;: <span class=\"hljs-number\">88.29</span> KB (<span class=\"hljs-number\">22.0</span>%)\n</code></pre><p>除非SPA自身的代码超过1M，否则那分出去的一小部分路由就只有几十KB，效果堪称鸡肋。</p>\n<p>那么，有没有一个办法，既能让所有路由全部按需分块加载，并且完全不影响首屏速度的效果呢？</p>\n<p>答案是有的，本文就是介绍如何使用SSR的服务端，来达到这样的效果。</p>\n<p>博主称之为按需分块加载的首屏优化策略</p>\n<h1><a href='#demo' id='demo' class='anchor'></a><a href='#demo'>Demo</a></h1><p>目前，本博客的所有页面均使用了这种首屏优化策略，读者可以自行刷新页面，可以发现，没有任何异步标签被jsonp生成。</p>\n<p>实际上，所有路由都被分出去后，app.js从533KB降到了504KB（未gzip前），刚好减小了一个vue-meta的大小，博主之所有做这个优化的原因，也是因为使用了vue-meta后app.js增加的代码太多，希望能通过分块来减小打包大小。</p>\n<p>从结果来说，效果刚好达到博主的期望</p>\n<h1><a href='#流程' id='流程' class='anchor'></a><a href='#流程'>流程</a></h1><p>本文策略的流程如下</p>\n<ul>\n<li>服务器启动时将所有分块文件读进内存</li>\n<li>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</li>\n<li>根据名称获取内容后，直接和全局状态window.__INITIAL<em>STATE</em>一同写回response</li>\n<li>在客户端手动做合并分块的操作</li>\n<li>简单修改异步组件</li>\n</ul>\n<p>由于开发环境做这种首屏优化意义相当小，因为前端工程师开发时关注的并不是加载速度，所以这也是一个正式环境下独享的一种优化策略。</p>\n<h1><a href='#服务器启动时将所有分块文件读进内存' id='服务器启动时将所有分块文件读进内存' class='anchor'></a><a href='#服务器启动时将所有分块文件读进内存'>服务器启动时将所有分块文件读进内存</a></h1><p>这里判定名称数组长度为3的是分块文件，依据是本博客webpack打包时加入了hash值，格式为<code>name.[hash].js</code>。<br>如果读者没有加入hash，自行修改数组长度为2即可。</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">const</span> chunkObj = {}\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  <span class=\"hljs-keyword\">const</span> fileArr = fs.readdirSync(<span class=\"hljs-string\">'./dist'</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = fileArr.length; i &lt; len; i++) {\n    <span class=\"hljs-keyword\">const</span> fileName = fileArr[i]\n    <span class=\"hljs-keyword\">const</span> arr = fileName.split(<span class=\"hljs-string\">'.'</span>)\n    <span class=\"hljs-keyword\">if</span> (arr.length === <span class=\"hljs-number\">3</span> &amp;&amp; arr[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'app'</span>) {\n      <span class=\"hljs-keyword\">const</span> input = fs.readFileSync(<span class=\"hljs-string\">`./dist/<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">'utf-8'</span>)\n      chunkObj[fileName] = input\n    }\n  }\n}\n</code></pre>\n<h1><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' id='首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' class='anchor'></a><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称'>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></h1><p>这一步是如果不知道分块命名的话是非常难的，原因在于，System.import导入的多个异步组件时，他们的导入顺序是无序的，因为都是ES6 Module异步导入，至少博主没有发现这个顺序有算出来的办法。</p>\n<p>另外，异步组件只能在客户端中拿到分块的名称，此时导入异步组件的函数如下：</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> __webpack_require__.e<span class=\"hljs-comment\">/* import() */</span>(<span class=\"hljs-number\">4</span>).then(__webpack_require__.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">51</span>));\n}\n</code></pre>\n<p>可以使用webpack命名分块的功能来实现这一点, 我专门列了<a href=\"https://smallpath.me/post/webpack-on-demand-chunk-name\">一篇文章</a></p>\n<p>在上面这个链接的情况下, 需要定义好分块的名称</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!process.BROWSER) {\n  Post<span class=\"hljs-selector-class\">.chunkName</span> = Page<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'CreatePostView'</span>\n  TagPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'TagPager'</span>\n  Tag<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Tag'</span>\n  BlogPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'BlogPager'</span>\n  Archive<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Archive'</span>\n}\n</code></pre><h1><a href='#根据名称获取内容后，拼好html写回response' id='根据名称获取内容后，拼好html写回response' class='anchor'></a><a href='#根据名称获取内容后，拼好html写回response'>根据名称获取内容后，拼好HTML写回response</a></h1><h2><a href='#修改server-entry.js' id='修改server-entry.js' class='anchor'></a><a href='#修改server-entry.js'>修改server-entry.js</a></h2><pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">return</span> Promise.all(router.getMatchedComponents().map(<span class=\"hljs-function\"><span class=\"hljs-params\">(component, index)</span> =&gt;</span> {\n    <span class=\"hljs-regexp\">//</span> 新增如下四句\n    const chunkName = component.chunkName\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> chunkName === <span class=\"hljs-string\">'string'</span>) {\n      context.chunkName = chunkName\n    }\n    <span class=\"hljs-keyword\">if</span> (component.preFetch) {\n      <span class=\"hljs-keyword\">return</span> component.preFetch(store, context).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n  })).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(arr)</span> =&gt;</span> {\n    isDev &amp;&amp; <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">data pre-fetch: ${<span class=\"hljs-built_in\">Date</span>.now() - s}ms</span>`)\n\n    context.initialState = store.state\n    <span class=\"hljs-keyword\">return</span> realApp\n  })\n</code></pre><h2><a href='#修改renderstream的end事件' id='修改renderstream的end事件' class='anchor'></a><a href='#修改renderstream的end事件'>修改renderStream的end事件</a></h2><pre class=\"hljs\"><code>    renderStream.<span class=\"hljs-keyword\">on</span>(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (context.initialState) {\n        <span class=\"hljs-keyword\">res</span>.<span class=\"hljs-keyword\">write</span>(\n          `<span class=\"hljs-symbol\">&lt;script&gt;</span>window.__INITIAL_STATE__=${\n          JSON.stringify(context.initialState)\n          }&lt;/script&gt;`\n        )\n      }\n\n      <span class=\"hljs-keyword\">let</span> tail = html.tail\n      <span class=\"hljs-keyword\">if</span> (isProd &amp;&amp; typeof context.chunkName === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key in chunkObj) {\n          <span class=\"hljs-keyword\">if</span> (key.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>] === context.chunkName) {\n            const chunk = `&lt;script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> charset=<span class=\"hljs-string\">\"utf-8\"</span>&gt;${chunkObj[key]}&lt;/script&gt;&lt;/body&gt;`\n            tail = tail.replace(<span class=\"hljs-string\">'&lt;/body&gt;'</span>, chunk)\n            <span class=\"hljs-keyword\">break</span>\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">res</span>.end(tail)\n      <span class=\"hljs-built_in\">log</span>.<span class=\"hljs-keyword\">debug</span>(`whole reques<span class=\"hljs-variable\">t:</span> ${Date.now() - s}ms`)\n    })\n</code></pre><h1><a href='#在客户端手动做合并分块的操作' id='在客户端手动做合并分块的操作' class='anchor'></a><a href='#在客户端手动做合并分块的操作'>在客户端手动做合并分块的操作</a></h1><p>这一步也是难点，相当坑，坑死人。</p>\n<p>博主的webpack配置中，由于要使用tree-shaking来省下20KB左右的打包大小，因此没有分vendor公共块出去。</p>\n<p>如果分了vendor，那么直接把上一步生成的script标签迁移到vendor块的script标签之后和app块的script标签之前，就可以保证在vue运行前执行了我们生成好的那个分块了。</p>\n<p>但是既然没有分块，所有代码都在app.js中，那么就需要延迟vue运行，以确保app.js标签后面的我们追加的script标签内容比vue先运行</p>\n<p>否则vue-router会提前发现该组件是异步组件，然后它就自己帮我们调用webpackJsonp生成好async script标签了，这本来就是本文要避免的。</p>\n<h2><a href='#延迟app根实例的产生' id='延迟app根实例的产生' class='anchor'></a><a href='#延迟app根实例的产生'>延迟app根实例的产生</a></h2><pre class=\"hljs\"><code>const <span class=\"hljs-attr\">isProd</span> = process.env.<span class=\"hljs-attr\">NODE_ENV</span> === 'production'\n\nconst <span class=\"hljs-attr\">appOption</span> = {\n  router,\n  store,\n  ...App\n}\n\n<span class=\"hljs-keyword\">let</span> app\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-attr\">isProd</span> === <span class=\"hljs-literal\">false</span>) {\n  <span class=\"hljs-attr\">app</span> = new Vue(appOption)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">preFetchComponent</span> = [\n  Sidebar\n]\n\nexport { app, appOption, router, store, preFetchComponent, isProd }\n</code></pre><h3><a href='#在服务端生成根实例' id='在服务端生成根实例' class='anchor'></a><a href='#在服务端生成根实例'>在服务端生成根实例</a></h3><p>本文和服务端入口文件没关系，直接生成</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, preFetchComponent, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> isDev = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n</code></pre><h3><a href='#延迟客户端根实例的产生与挂载' id='延迟客户端根实例的产生与挂载' class='anchor'></a><a href='#延迟客户端根实例的产生与挂载'>延迟客户端根实例的产生与挂载</a></h3><pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> callback = isProd ? setTimeout : router.onReady.bind(router)\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">true</span>\n}\n\ncallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isProd) store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n\n  <span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__.route.hash = <span class=\"hljs-built_in\">window</span>.location.hash\n  store.replaceState(<span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__)\n  realApp.$mount(<span class=\"hljs-string\">'#app'</span>)\n})\n</code></pre><p>router.onReady为vue-router 2.2.0的新增方法，在客户端异步组件加载完时触发，我们只在开发环境调用这个回调，用来确保客户端hydrate出来的HTML和SSR出来的一致。</p>\n<p>到了正式环境，直接用setTimeout来延迟加载了。</p>\n<h1><a href='#简单修改异步组件' id='简单修改异步组件' class='anchor'></a><a href='#简单修改异步组件'>简单修改异步组件</a></h1><h2><a href='#修改全局状态' id='修改全局状态' class='anchor'></a><a href='#修改全局状态'>修改全局状态</a></h2><p>添加如下的状态</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">isLoadingAsyncComponent:</span> <span class=\"hljs-literal\">false</span>\n</code></pre><h2><a href='#对应修改异步组件' id='对应修改异步组件' class='anchor'></a><a href='#对应修改异步组件'>对应修改异步组件</a></h2><pre class=\"hljs\"><code>  preFetch: fetchAchieves,\n  beforeMount () {\n    <span class=\"hljs-keyword\">this</span>.isLoadingAsyncComponent &amp;&amp; <span class=\"hljs-keyword\">this</span>.$root._isMounted &amp;&amp; fetchAchieves(<span class=\"hljs-keyword\">this</span>.$store, <span class=\"hljs-keyword\">this</span>.$route)\n  }\n</code></pre><p>不用这个状态来标志的话，客户端组件会在SSR数据已经存在的情况下再次获取组件，造成浪费</p>\n<h2><a href='#选择性优化客户端的router钩子' id='选择性优化客户端的router钩子' class='anchor'></a><a href='#选择性优化客户端的router钩子'>选择性优化客户端的router钩子</a></h2><p>如果你使用了router的两个钩子，建议做如下处理</p>\n<h3><a href='#router.aftereach' id='router.aftereach' class='anchor'></a><a href='#router.aftereach'>router.afterEach</a></h3><pre class=\"hljs\"><code>router.afterEach((<span class=\"hljs-keyword\">to</span>, <span class=\"hljs-keyword\">from</span>) =&gt; {\n  <span class=\"hljs-comment\">// should delay it to get the correct title generated by vue-meta</span>\n  <span class=\"hljs-keyword\">from</span>.<span class=\"hljs-built_in\">name</span> &amp;&amp; clientGoogleAnalyse(<span class=\"hljs-keyword\">to</span>.path)\n})\n</code></pre><p>通过本文的延迟app挂载这种方法时，router.afterEach会在初始时被vue-router触发，博主猜测应当是vue处理异步组件后自行触发的，因此需要一个标志来避免触发。</p>\n<p>由于本博客所有路由都是具名路由，而这种触发时from.name会为null，据此可以做过滤</p>\n<h3><a href='#router.beforeeach' id='router.beforeeach' class='anchor'></a><a href='#router.beforeeach'>router.beforeEach</a></h3><p>异步组件的存在，导致数据获取的流程发生了变化，首先是异步组件被加载好，再触发异步组件的preFetch钩子进行数据获取，最后根据数据是否正常判断是否该进入路由。</p>\n<p>如果不按这个流程来，会出现新路由数据尚未获取到就进入了该组件的情况，当数据拿到时会发生一次闪屏，不仅无法控制路由，而且用户体验非常差。</p>\n<p>读者可以参考如下的数据获取流程</p>\n<pre class=\"hljs\"><code>router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 仅hash变化时，直接进入路由</span>\n  <span class=\"hljs-keyword\">if</span> (to.path === <span class=\"hljs-keyword\">from</span>.path &amp;&amp; to.hash !== <span class=\"hljs-keyword\">from</span>.hash) {\n    <span class=\"hljs-keyword\">return</span> next()\n  }\n\n  <span class=\"hljs-comment\">// Loading组件开始加载</span>\n  <span class=\"hljs-keyword\">let</span> loadingPromise = store.dispatch(<span class=\"hljs-string\">'START_LOADING'</span>)\n  <span class=\"hljs-keyword\">let</span> endLoadingCallback = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> loadingPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">interval</span> =&gt;</span> {\n      clearInterval(interval)\n      store.dispatch(<span class=\"hljs-string\">'SET_PROGRESS'</span>, <span class=\"hljs-number\">100</span>)\n      next()\n    })\n  }\n\n  <span class=\"hljs-comment\">// 根据本博客的路由定义，一定有一个组件能够被匹配到</span>\n  <span class=\"hljs-keyword\">let</span> component = router.getMatchedComponents(to.fullPath)[<span class=\"hljs-number\">0</span>]\n\n  <span class=\"hljs-comment\">// 如果是一个异步组件，我们手动resolve它，再接着调用它的preFetch接口，这样可以避免闪屏</span>\n  <span class=\"hljs-comment\">// 异步组件也是一个函数，但是它没有options这个值，可以据此做条件判断</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> component === <span class=\"hljs-string\">'function'</span> &amp;&amp; !component.options) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 一个resolve函数</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">realComponent</span> =&gt;</span> {\n        resolve(realComponent)\n      }\n      <span class=\"hljs-comment\">// 对普通异步组件来说，它会在第一层中被直接resolve，因此直接将resolve函数传给它调用</span>\n      <span class=\"hljs-keyword\">let</span> res = component(_resolve)\n      <span class=\"hljs-comment\">// 对工厂模式的组件生成函数来说，它第一层中产生的只是工厂函数，组件是在第二步中产生的</span>\n      <span class=\"hljs-comment\">// 这种工厂函数是thenable的，因此将resolve函数用then传给第二层调用</span>\n      <span class=\"hljs-keyword\">if</span> (res &amp;&amp; res.then) {\n        res.then(_resolve)\n      }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">component</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的component就是异步组件加载完毕后的真实组件了，开始调用数据获取函数</span>\n      <span class=\"hljs-keyword\">return</span> letsGo(component, store, to, endLoadingCallback)\n    })\n  }\n  <span class=\"hljs-comment\">// 调用数据获取函数</span>\n  letsGo(component, store, to, endLoadingCallback)\n})\n\n<span class=\"hljs-comment\">// 数据获取函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letsGo</span> (<span class=\"hljs-params\">component, store, to, endLoadingCallback</span>) </span>{\n  <span class=\"hljs-comment\">// 如果preFetch钩子存在，调用这个钩子，并将endLoadingCallback这个停止loading并进入路由的回调传给它</span>\n  <span class=\"hljs-keyword\">if</span> (component &amp;&amp; component.preFetch) {\n    <span class=\"hljs-keyword\">return</span> component.preFetch(store, to, endLoadingCallback).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-built_in\">Date</span>.now().toLocaleString(), err)\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 如果preFetch钩子不存在，说明这是一个静态页面，直接导航进入。</span>\n    endLoadingCallback()\n  }\n}\n</code></pre><p>这里给出preFetch的模板</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-tag\">function</span> <span class=\"hljs-selector-tag\">preFetch</span> (store, { <span class=\"hljs-attribute\">path</span>: pathName, params, query }, <span class=\"hljs-selector-tag\">callback</span>) {\n  <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">store</span><span class=\"hljs-selector-class\">.dispatch</span>(<span class=\"hljs-string\">'FETCH_TAGS'</span>, {\n    <span class=\"hljs-attribute\">model</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attribute\">query</span>: {\n      <span class=\"hljs-attribute\">conditions</span>: {\n        <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'post'</span>,\n        <span class=\"hljs-attribute\">isPublic</span>: true\n      },\n      <span class=\"hljs-attribute\">select</span>: {\n        <span class=\"hljs-attribute\">_id</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attribute\">tags</span>: <span class=\"hljs-number\">1</span>\n      }\n    },\n    callback\n  })\n}\n</code></pre><p>这种模板既能让它在SSR中被调用，又可以在客户端中被路由权限控制调用，十分有用</p>\n<p>最后，在action中手动调用callback这个参数，即可停止loading并进入路由了</p>\n<h1><a href='#结语' id='结语' class='anchor'></a><a href='#结语'>结语</a></h1><p>本文介绍的这种所有路由全部按需分块加载并完全不影响首屏速度的策略，是首屏优化中极少有人关注的。</p>\n<p>然而，它的效果十分强大，按这种策略优化首屏之后，配合SSR的SPA可以任意扩展体积与功能，并且首屏渲染将和SPA只有首屏页面时几乎一模一样。例如，本博客现在就可以毫无顾忌地开始做搜索页面了。</p>\n<p>最后，非常明显的是，本文的策略会带来一个问题，即非首屏的访问速度将会被拖慢，因为需要浏览器自行发起jsonp请求。解决办法其实也比较简单，只需要在首屏加载完成后让浏览器自行请求并缓存好对应的分块即可，这要求我们在构建时就必须得知分块的路径，并且需要搭配一个超强的请求拦截器，这也正是博主下一篇文章的内容。</p>\n"
},{
  "id": "7",
  "author": "qixin",
  "title": "7-setState 之后发生了什么 —— 浅谈 React 中的 Transaction",
  "description": "本文系对 深入理解 React 的 batchUpdate 机制 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。 之前在我的博客里有[...]",
  "pathName": "what-will-happen-after-setState-invoking-7",
  "tags": [
    "服务端渲染",
    "webpack",
    "vue",
    "性能调优",
    "Node.js",
    "express.js",
    "ES6 Module",
    "按需分块加载"
  ],
  "updatedAt": "2017-05-19 21:26:34",
  "createdAt": "2017-04-04 11:34:28",
  "toc": "<p><strong>文章目录</strong></p>\n<ul>\n<li><a href=\"#背景\">背景</a></li>\n<li><a href=\"#demo\">Demo</a></li>\n<li><a href=\"#流程\">流程</a></li>\n<li><a href=\"#服务器启动时将所有分块文件读进内存\">服务器启动时将所有分块文件读进内存</a></li>\n<li><a href=\"#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称\">首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></li>\n<li><a href=\"#根据名称获取内容后，拼好html写回response\">根据名称获取内容后，拼好HTML写回response</a><ul>\n<li><a href=\"#修改server-entry.js\">修改server-entry.js</a></li>\n<li><a href=\"#修改renderstream的end事件\">修改renderStream的end事件</a></li>\n</ul>\n</li>\n<li><a href=\"#在客户端手动做合并分块的操作\">在客户端手动做合并分块的操作</a><ul>\n<li><a href=\"#延迟app根实例的产生\">延迟app根实例的产生</a><ul>\n<li><a href=\"#在服务端生成根实例\">在服务端生成根实例</a></li>\n<li><a href=\"#延迟客户端根实例的产生与挂载\">延迟客户端根实例的产生与挂载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#简单修改异步组件\">简单修改异步组件</a><ul>\n<li><a href=\"#修改全局状态\">修改全局状态</a></li>\n<li><a href=\"#对应修改异步组件\">对应修改异步组件</a></li>\n<li><a href=\"#选择性优化客户端的router钩子\">选择性优化客户端的router钩子</a><ul>\n<li><a href=\"#router.aftereach\">router.afterEach</a></li>\n<li><a href=\"#router.beforeeach\">router.beforeEach</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#结语\">结语</a></li>\n</ul>\n",
  "html": "<p>本文介绍一种SSR与按需分块加载的首屏优化策略，可以达到将所有路由全部按需分块加载，并且完全不影响首屏速度的效果。</p>\n<h1><a href='#背景' id='背景' class='anchor'></a><a href='#背景'>背景</a></h1><p>SSR与按需分块加载，博主最初使用下来感觉其实意义有限</p>\n<p>假如全部路由都使用按需分块加载，那么首屏时间很可能不降反增，因为首屏对应的组件也同样要在客户端通过jsonp生成async script标签并异步获得。生成的标签如下：</p>\n<pre class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/dist/4.5e0b0c5a53f9c9a9cbfd.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这会严重影响首屏加载速度。</p>\n<p>假如又只有一小部分不常被访问的路由需要使用按需分块加载，那么能节省的代码量可能非常小，以博客为例，vue全家桶加一些其他的依赖占了几乎80%的体积</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.10</span>@vue: <span class=\"hljs-number\">157.97</span> KB (<span class=\"hljs-number\">39.3</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span>@vue-router: <span class=\"hljs-number\">54.82</span> KB (<span class=\"hljs-number\">13.6</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.15</span><span class=\"hljs-number\">.3</span>@axios: <span class=\"hljs-number\">35.04</span> KB (<span class=\"hljs-number\">8.72</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.5</span><span class=\"hljs-number\">.3</span>@vue-meta: <span class=\"hljs-number\">29.31</span> KB (<span class=\"hljs-number\">7.29</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>@vuex: <span class=\"hljs-number\">20.49</span> KB (<span class=\"hljs-number\">5.10</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vue-style-loader: <span class=\"hljs-number\">6.79</span> KB (<span class=\"hljs-number\">1.69</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.11</span><span class=\"hljs-number\">.9</span>@process: <span class=\"hljs-number\">5.17</span> KB (<span class=\"hljs-number\">1.29</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.25</span><span class=\"hljs-number\">.0</span>@css-loader: <span class=\"hljs-number\">1.47</span> KB (<span class=\"hljs-number\">0.366</span>%)\n<span class=\"hljs-number\">.10</span><span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span>@vue-loader: <span class=\"hljs-number\">1.09</span> KB (<span class=\"hljs-number\">0.271</span>%)\n<span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vuex-router-sync: <span class=\"hljs-number\">981</span> B (<span class=\"hljs-number\">0.238</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span>@webpack: <span class=\"hljs-number\">509</span> B (<span class=\"hljs-number\">0.124</span>%)\n&lt;self&gt;: <span class=\"hljs-number\">88.29</span> KB (<span class=\"hljs-number\">22.0</span>%)\n</code></pre><p>除非SPA自身的代码超过1M，否则那分出去的一小部分路由就只有几十KB，效果堪称鸡肋。</p>\n<p>那么，有没有一个办法，既能让所有路由全部按需分块加载，并且完全不影响首屏速度的效果呢？</p>\n<p>答案是有的，本文就是介绍如何使用SSR的服务端，来达到这样的效果。</p>\n<p>博主称之为按需分块加载的首屏优化策略</p>\n<h1><a href='#demo' id='demo' class='anchor'></a><a href='#demo'>Demo</a></h1><p>目前，本博客的所有页面均使用了这种首屏优化策略，读者可以自行刷新页面，可以发现，没有任何异步标签被jsonp生成。</p>\n<p>实际上，所有路由都被分出去后，app.js从533KB降到了504KB（未gzip前），刚好减小了一个vue-meta的大小，博主之所有做这个优化的原因，也是因为使用了vue-meta后app.js增加的代码太多，希望能通过分块来减小打包大小。</p>\n<p>从结果来说，效果刚好达到博主的期望</p>\n<h1><a href='#流程' id='流程' class='anchor'></a><a href='#流程'>流程</a></h1><p>本文策略的流程如下</p>\n<ul>\n<li>服务器启动时将所有分块文件读进内存</li>\n<li>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</li>\n<li>根据名称获取内容后，直接和全局状态window.__INITIAL<em>STATE</em>一同写回response</li>\n<li>在客户端手动做合并分块的操作</li>\n<li>简单修改异步组件</li>\n</ul>\n<p>由于开发环境做这种首屏优化意义相当小，因为前端工程师开发时关注的并不是加载速度，所以这也是一个正式环境下独享的一种优化策略。</p>\n<h1><a href='#服务器启动时将所有分块文件读进内存' id='服务器启动时将所有分块文件读进内存' class='anchor'></a><a href='#服务器启动时将所有分块文件读进内存'>服务器启动时将所有分块文件读进内存</a></h1><p>这里判定名称数组长度为3的是分块文件，依据是本博客webpack打包时加入了hash值，格式为<code>name.[hash].js</code>。<br>如果读者没有加入hash，自行修改数组长度为2即可。</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">const</span> chunkObj = {}\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  <span class=\"hljs-keyword\">const</span> fileArr = fs.readdirSync(<span class=\"hljs-string\">'./dist'</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = fileArr.length; i &lt; len; i++) {\n    <span class=\"hljs-keyword\">const</span> fileName = fileArr[i]\n    <span class=\"hljs-keyword\">const</span> arr = fileName.split(<span class=\"hljs-string\">'.'</span>)\n    <span class=\"hljs-keyword\">if</span> (arr.length === <span class=\"hljs-number\">3</span> &amp;&amp; arr[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'app'</span>) {\n      <span class=\"hljs-keyword\">const</span> input = fs.readFileSync(<span class=\"hljs-string\">`./dist/<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">'utf-8'</span>)\n      chunkObj[fileName] = input\n    }\n  }\n}\n</code></pre>\n<h1><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' id='首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' class='anchor'></a><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称'>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></h1><p>这一步是如果不知道分块命名的话是非常难的，原因在于，System.import导入的多个异步组件时，他们的导入顺序是无序的，因为都是ES6 Module异步导入，至少博主没有发现这个顺序有算出来的办法。</p>\n<p>另外，异步组件只能在客户端中拿到分块的名称，此时导入异步组件的函数如下：</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> __webpack_require__.e<span class=\"hljs-comment\">/* import() */</span>(<span class=\"hljs-number\">4</span>).then(__webpack_require__.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">51</span>));\n}\n</code></pre>\n<p>可以使用webpack命名分块的功能来实现这一点, 我专门列了<a href=\"https://smallpath.me/post/webpack-on-demand-chunk-name\">一篇文章</a></p>\n<p>在上面这个链接的情况下, 需要定义好分块的名称</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!process.BROWSER) {\n  Post<span class=\"hljs-selector-class\">.chunkName</span> = Page<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'CreatePostView'</span>\n  TagPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'TagPager'</span>\n  Tag<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Tag'</span>\n  BlogPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'BlogPager'</span>\n  Archive<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Archive'</span>\n}\n</code></pre><h1><a href='#根据名称获取内容后，拼好html写回response' id='根据名称获取内容后，拼好html写回response' class='anchor'></a><a href='#根据名称获取内容后，拼好html写回response'>根据名称获取内容后，拼好HTML写回response</a></h1><h2><a href='#修改server-entry.js' id='修改server-entry.js' class='anchor'></a><a href='#修改server-entry.js'>修改server-entry.js</a></h2><pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">return</span> Promise.all(router.getMatchedComponents().map(<span class=\"hljs-function\"><span class=\"hljs-params\">(component, index)</span> =&gt;</span> {\n    <span class=\"hljs-regexp\">//</span> 新增如下四句\n    const chunkName = component.chunkName\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> chunkName === <span class=\"hljs-string\">'string'</span>) {\n      context.chunkName = chunkName\n    }\n    <span class=\"hljs-keyword\">if</span> (component.preFetch) {\n      <span class=\"hljs-keyword\">return</span> component.preFetch(store, context).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n  })).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(arr)</span> =&gt;</span> {\n    isDev &amp;&amp; <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">data pre-fetch: ${<span class=\"hljs-built_in\">Date</span>.now() - s}ms</span>`)\n\n    context.initialState = store.state\n    <span class=\"hljs-keyword\">return</span> realApp\n  })\n</code></pre><h2><a href='#修改renderstream的end事件' id='修改renderstream的end事件' class='anchor'></a><a href='#修改renderstream的end事件'>修改renderStream的end事件</a></h2><pre class=\"hljs\"><code>    renderStream.<span class=\"hljs-keyword\">on</span>(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (context.initialState) {\n        <span class=\"hljs-keyword\">res</span>.<span class=\"hljs-keyword\">write</span>(\n          `<span class=\"hljs-symbol\">&lt;script&gt;</span>window.__INITIAL_STATE__=${\n          JSON.stringify(context.initialState)\n          }&lt;/script&gt;`\n        )\n      }\n\n      <span class=\"hljs-keyword\">let</span> tail = html.tail\n      <span class=\"hljs-keyword\">if</span> (isProd &amp;&amp; typeof context.chunkName === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key in chunkObj) {\n          <span class=\"hljs-keyword\">if</span> (key.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>] === context.chunkName) {\n            const chunk = `&lt;script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> charset=<span class=\"hljs-string\">\"utf-8\"</span>&gt;${chunkObj[key]}&lt;/script&gt;&lt;/body&gt;`\n            tail = tail.replace(<span class=\"hljs-string\">'&lt;/body&gt;'</span>, chunk)\n            <span class=\"hljs-keyword\">break</span>\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">res</span>.end(tail)\n      <span class=\"hljs-built_in\">log</span>.<span class=\"hljs-keyword\">debug</span>(`whole reques<span class=\"hljs-variable\">t:</span> ${Date.now() - s}ms`)\n    })\n</code></pre><h1><a href='#在客户端手动做合并分块的操作' id='在客户端手动做合并分块的操作' class='anchor'></a><a href='#在客户端手动做合并分块的操作'>在客户端手动做合并分块的操作</a></h1><p>这一步也是难点，相当坑，坑死人。</p>\n<p>博主的webpack配置中，由于要使用tree-shaking来省下20KB左右的打包大小，因此没有分vendor公共块出去。</p>\n<p>如果分了vendor，那么直接把上一步生成的script标签迁移到vendor块的script标签之后和app块的script标签之前，就可以保证在vue运行前执行了我们生成好的那个分块了。</p>\n<p>但是既然没有分块，所有代码都在app.js中，那么就需要延迟vue运行，以确保app.js标签后面的我们追加的script标签内容比vue先运行</p>\n<p>否则vue-router会提前发现该组件是异步组件，然后它就自己帮我们调用webpackJsonp生成好async script标签了，这本来就是本文要避免的。</p>\n<h2><a href='#延迟app根实例的产生' id='延迟app根实例的产生' class='anchor'></a><a href='#延迟app根实例的产生'>延迟app根实例的产生</a></h2><pre class=\"hljs\"><code>const <span class=\"hljs-attr\">isProd</span> = process.env.<span class=\"hljs-attr\">NODE_ENV</span> === 'production'\n\nconst <span class=\"hljs-attr\">appOption</span> = {\n  router,\n  store,\n  ...App\n}\n\n<span class=\"hljs-keyword\">let</span> app\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-attr\">isProd</span> === <span class=\"hljs-literal\">false</span>) {\n  <span class=\"hljs-attr\">app</span> = new Vue(appOption)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">preFetchComponent</span> = [\n  Sidebar\n]\n\nexport { app, appOption, router, store, preFetchComponent, isProd }\n</code></pre><h3><a href='#在服务端生成根实例' id='在服务端生成根实例' class='anchor'></a><a href='#在服务端生成根实例'>在服务端生成根实例</a></h3><p>本文和服务端入口文件没关系，直接生成</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, preFetchComponent, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> isDev = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n</code></pre><h3><a href='#延迟客户端根实例的产生与挂载' id='延迟客户端根实例的产生与挂载' class='anchor'></a><a href='#延迟客户端根实例的产生与挂载'>延迟客户端根实例的产生与挂载</a></h3><pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> callback = isProd ? setTimeout : router.onReady.bind(router)\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">true</span>\n}\n\ncallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isProd) store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n\n  <span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__.route.hash = <span class=\"hljs-built_in\">window</span>.location.hash\n  store.replaceState(<span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__)\n  realApp.$mount(<span class=\"hljs-string\">'#app'</span>)\n})\n</code></pre><p>router.onReady为vue-router 2.2.0的新增方法，在客户端异步组件加载完时触发，我们只在开发环境调用这个回调，用来确保客户端hydrate出来的HTML和SSR出来的一致。</p>\n<p>到了正式环境，直接用setTimeout来延迟加载了。</p>\n<h1><a href='#简单修改异步组件' id='简单修改异步组件' class='anchor'></a><a href='#简单修改异步组件'>简单修改异步组件</a></h1><h2><a href='#修改全局状态' id='修改全局状态' class='anchor'></a><a href='#修改全局状态'>修改全局状态</a></h2><p>添加如下的状态</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">isLoadingAsyncComponent:</span> <span class=\"hljs-literal\">false</span>\n</code></pre><h2><a href='#对应修改异步组件' id='对应修改异步组件' class='anchor'></a><a href='#对应修改异步组件'>对应修改异步组件</a></h2><pre class=\"hljs\"><code>  preFetch: fetchAchieves,\n  beforeMount () {\n    <span class=\"hljs-keyword\">this</span>.isLoadingAsyncComponent &amp;&amp; <span class=\"hljs-keyword\">this</span>.$root._isMounted &amp;&amp; fetchAchieves(<span class=\"hljs-keyword\">this</span>.$store, <span class=\"hljs-keyword\">this</span>.$route)\n  }\n</code></pre><p>不用这个状态来标志的话，客户端组件会在SSR数据已经存在的情况下再次获取组件，造成浪费</p>\n<h2><a href='#选择性优化客户端的router钩子' id='选择性优化客户端的router钩子' class='anchor'></a><a href='#选择性优化客户端的router钩子'>选择性优化客户端的router钩子</a></h2><p>如果你使用了router的两个钩子，建议做如下处理</p>\n<h3><a href='#router.aftereach' id='router.aftereach' class='anchor'></a><a href='#router.aftereach'>router.afterEach</a></h3><pre class=\"hljs\"><code>router.afterEach((<span class=\"hljs-keyword\">to</span>, <span class=\"hljs-keyword\">from</span>) =&gt; {\n  <span class=\"hljs-comment\">// should delay it to get the correct title generated by vue-meta</span>\n  <span class=\"hljs-keyword\">from</span>.<span class=\"hljs-built_in\">name</span> &amp;&amp; clientGoogleAnalyse(<span class=\"hljs-keyword\">to</span>.path)\n})\n</code></pre><p>通过本文的延迟app挂载这种方法时，router.afterEach会在初始时被vue-router触发，博主猜测应当是vue处理异步组件后自行触发的，因此需要一个标志来避免触发。</p>\n<p>由于本博客所有路由都是具名路由，而这种触发时from.name会为null，据此可以做过滤</p>\n<h3><a href='#router.beforeeach' id='router.beforeeach' class='anchor'></a><a href='#router.beforeeach'>router.beforeEach</a></h3><p>异步组件的存在，导致数据获取的流程发生了变化，首先是异步组件被加载好，再触发异步组件的preFetch钩子进行数据获取，最后根据数据是否正常判断是否该进入路由。</p>\n<p>如果不按这个流程来，会出现新路由数据尚未获取到就进入了该组件的情况，当数据拿到时会发生一次闪屏，不仅无法控制路由，而且用户体验非常差。</p>\n<p>读者可以参考如下的数据获取流程</p>\n<pre class=\"hljs\"><code>router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 仅hash变化时，直接进入路由</span>\n  <span class=\"hljs-keyword\">if</span> (to.path === <span class=\"hljs-keyword\">from</span>.path &amp;&amp; to.hash !== <span class=\"hljs-keyword\">from</span>.hash) {\n    <span class=\"hljs-keyword\">return</span> next()\n  }\n\n  <span class=\"hljs-comment\">// Loading组件开始加载</span>\n  <span class=\"hljs-keyword\">let</span> loadingPromise = store.dispatch(<span class=\"hljs-string\">'START_LOADING'</span>)\n  <span class=\"hljs-keyword\">let</span> endLoadingCallback = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> loadingPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">interval</span> =&gt;</span> {\n      clearInterval(interval)\n      store.dispatch(<span class=\"hljs-string\">'SET_PROGRESS'</span>, <span class=\"hljs-number\">100</span>)\n      next()\n    })\n  }\n\n  <span class=\"hljs-comment\">// 根据本博客的路由定义，一定有一个组件能够被匹配到</span>\n  <span class=\"hljs-keyword\">let</span> component = router.getMatchedComponents(to.fullPath)[<span class=\"hljs-number\">0</span>]\n\n  <span class=\"hljs-comment\">// 如果是一个异步组件，我们手动resolve它，再接着调用它的preFetch接口，这样可以避免闪屏</span>\n  <span class=\"hljs-comment\">// 异步组件也是一个函数，但是它没有options这个值，可以据此做条件判断</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> component === <span class=\"hljs-string\">'function'</span> &amp;&amp; !component.options) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 一个resolve函数</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">realComponent</span> =&gt;</span> {\n        resolve(realComponent)\n      }\n      <span class=\"hljs-comment\">// 对普通异步组件来说，它会在第一层中被直接resolve，因此直接将resolve函数传给它调用</span>\n      <span class=\"hljs-keyword\">let</span> res = component(_resolve)\n      <span class=\"hljs-comment\">// 对工厂模式的组件生成函数来说，它第一层中产生的只是工厂函数，组件是在第二步中产生的</span>\n      <span class=\"hljs-comment\">// 这种工厂函数是thenable的，因此将resolve函数用then传给第二层调用</span>\n      <span class=\"hljs-keyword\">if</span> (res &amp;&amp; res.then) {\n        res.then(_resolve)\n      }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">component</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的component就是异步组件加载完毕后的真实组件了，开始调用数据获取函数</span>\n      <span class=\"hljs-keyword\">return</span> letsGo(component, store, to, endLoadingCallback)\n    })\n  }\n  <span class=\"hljs-comment\">// 调用数据获取函数</span>\n  letsGo(component, store, to, endLoadingCallback)\n})\n\n<span class=\"hljs-comment\">// 数据获取函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letsGo</span> (<span class=\"hljs-params\">component, store, to, endLoadingCallback</span>) </span>{\n  <span class=\"hljs-comment\">// 如果preFetch钩子存在，调用这个钩子，并将endLoadingCallback这个停止loading并进入路由的回调传给它</span>\n  <span class=\"hljs-keyword\">if</span> (component &amp;&amp; component.preFetch) {\n    <span class=\"hljs-keyword\">return</span> component.preFetch(store, to, endLoadingCallback).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-built_in\">Date</span>.now().toLocaleString(), err)\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 如果preFetch钩子不存在，说明这是一个静态页面，直接导航进入。</span>\n    endLoadingCallback()\n  }\n}\n</code></pre><p>这里给出preFetch的模板</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-tag\">function</span> <span class=\"hljs-selector-tag\">preFetch</span> (store, { <span class=\"hljs-attribute\">path</span>: pathName, params, query }, <span class=\"hljs-selector-tag\">callback</span>) {\n  <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">store</span><span class=\"hljs-selector-class\">.dispatch</span>(<span class=\"hljs-string\">'FETCH_TAGS'</span>, {\n    <span class=\"hljs-attribute\">model</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attribute\">query</span>: {\n      <span class=\"hljs-attribute\">conditions</span>: {\n        <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'post'</span>,\n        <span class=\"hljs-attribute\">isPublic</span>: true\n      },\n      <span class=\"hljs-attribute\">select</span>: {\n        <span class=\"hljs-attribute\">_id</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attribute\">tags</span>: <span class=\"hljs-number\">1</span>\n      }\n    },\n    callback\n  })\n}\n</code></pre><p>这种模板既能让它在SSR中被调用，又可以在客户端中被路由权限控制调用，十分有用</p>\n<p>最后，在action中手动调用callback这个参数，即可停止loading并进入路由了</p>\n<h1><a href='#结语' id='结语' class='anchor'></a><a href='#结语'>结语</a></h1><p>本文介绍的这种所有路由全部按需分块加载并完全不影响首屏速度的策略，是首屏优化中极少有人关注的。</p>\n<p>然而，它的效果十分强大，按这种策略优化首屏之后，配合SSR的SPA可以任意扩展体积与功能，并且首屏渲染将和SPA只有首屏页面时几乎一模一样。例如，本博客现在就可以毫无顾忌地开始做搜索页面了。</p>\n<p>最后，非常明显的是，本文的策略会带来一个问题，即非首屏的访问速度将会被拖慢，因为需要浏览器自行发起jsonp请求。解决办法其实也比较简单，只需要在首屏加载完成后让浏览器自行请求并缓存好对应的分块即可，这要求我们在构建时就必须得知分块的路径，并且需要搭配一个超强的请求拦截器，这也正是博主下一篇文章的内容。</p>\n"
},{
  "id": "8",
  "author": "qixin",
  "title": "8-setState 之后发生了什么 —— 浅谈 React 中的 Transaction",
  "description": "本文系对 深入理解 React 的 batchUpdate 机制 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。 之前在我的博客里有[...]",
  "pathName": "what-will-happen-after-setState-invoking-8",
  "tags": [
    "服务端渲染",
    "webpack",
    "vue",
    "性能调优",
    "Node.js",
    "express.js",
    "ES6 Module",
    "按需分块加载"
  ],
  "updatedAt": "2017-05-19 21:26:34",
  "createdAt": "2017-04-04 11:34:28",
  "toc": "<p><strong>文章目录</strong></p>\n<ul>\n<li><a href=\"#背景\">背景</a></li>\n<li><a href=\"#demo\">Demo</a></li>\n<li><a href=\"#流程\">流程</a></li>\n<li><a href=\"#服务器启动时将所有分块文件读进内存\">服务器启动时将所有分块文件读进内存</a></li>\n<li><a href=\"#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称\">首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></li>\n<li><a href=\"#根据名称获取内容后，拼好html写回response\">根据名称获取内容后，拼好HTML写回response</a><ul>\n<li><a href=\"#修改server-entry.js\">修改server-entry.js</a></li>\n<li><a href=\"#修改renderstream的end事件\">修改renderStream的end事件</a></li>\n</ul>\n</li>\n<li><a href=\"#在客户端手动做合并分块的操作\">在客户端手动做合并分块的操作</a><ul>\n<li><a href=\"#延迟app根实例的产生\">延迟app根实例的产生</a><ul>\n<li><a href=\"#在服务端生成根实例\">在服务端生成根实例</a></li>\n<li><a href=\"#延迟客户端根实例的产生与挂载\">延迟客户端根实例的产生与挂载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#简单修改异步组件\">简单修改异步组件</a><ul>\n<li><a href=\"#修改全局状态\">修改全局状态</a></li>\n<li><a href=\"#对应修改异步组件\">对应修改异步组件</a></li>\n<li><a href=\"#选择性优化客户端的router钩子\">选择性优化客户端的router钩子</a><ul>\n<li><a href=\"#router.aftereach\">router.afterEach</a></li>\n<li><a href=\"#router.beforeeach\">router.beforeEach</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#结语\">结语</a></li>\n</ul>\n",
  "html": "<p>本文介绍一种SSR与按需分块加载的首屏优化策略，可以达到将所有路由全部按需分块加载，并且完全不影响首屏速度的效果。</p>\n<h1><a href='#背景' id='背景' class='anchor'></a><a href='#背景'>背景</a></h1><p>SSR与按需分块加载，博主最初使用下来感觉其实意义有限</p>\n<p>假如全部路由都使用按需分块加载，那么首屏时间很可能不降反增，因为首屏对应的组件也同样要在客户端通过jsonp生成async script标签并异步获得。生成的标签如下：</p>\n<pre class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/dist/4.5e0b0c5a53f9c9a9cbfd.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这会严重影响首屏加载速度。</p>\n<p>假如又只有一小部分不常被访问的路由需要使用按需分块加载，那么能节省的代码量可能非常小，以博客为例，vue全家桶加一些其他的依赖占了几乎80%的体积</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.10</span>@vue: <span class=\"hljs-number\">157.97</span> KB (<span class=\"hljs-number\">39.3</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span>@vue-router: <span class=\"hljs-number\">54.82</span> KB (<span class=\"hljs-number\">13.6</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.15</span><span class=\"hljs-number\">.3</span>@axios: <span class=\"hljs-number\">35.04</span> KB (<span class=\"hljs-number\">8.72</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.5</span><span class=\"hljs-number\">.3</span>@vue-meta: <span class=\"hljs-number\">29.31</span> KB (<span class=\"hljs-number\">7.29</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>@vuex: <span class=\"hljs-number\">20.49</span> KB (<span class=\"hljs-number\">5.10</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vue-style-loader: <span class=\"hljs-number\">6.79</span> KB (<span class=\"hljs-number\">1.69</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.11</span><span class=\"hljs-number\">.9</span>@process: <span class=\"hljs-number\">5.17</span> KB (<span class=\"hljs-number\">1.29</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.25</span><span class=\"hljs-number\">.0</span>@css-loader: <span class=\"hljs-number\">1.47</span> KB (<span class=\"hljs-number\">0.366</span>%)\n<span class=\"hljs-number\">.10</span><span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span>@vue-loader: <span class=\"hljs-number\">1.09</span> KB (<span class=\"hljs-number\">0.271</span>%)\n<span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vuex-router-sync: <span class=\"hljs-number\">981</span> B (<span class=\"hljs-number\">0.238</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span>@webpack: <span class=\"hljs-number\">509</span> B (<span class=\"hljs-number\">0.124</span>%)\n&lt;self&gt;: <span class=\"hljs-number\">88.29</span> KB (<span class=\"hljs-number\">22.0</span>%)\n</code></pre><p>除非SPA自身的代码超过1M，否则那分出去的一小部分路由就只有几十KB，效果堪称鸡肋。</p>\n<p>那么，有没有一个办法，既能让所有路由全部按需分块加载，并且完全不影响首屏速度的效果呢？</p>\n<p>答案是有的，本文就是介绍如何使用SSR的服务端，来达到这样的效果。</p>\n<p>博主称之为按需分块加载的首屏优化策略</p>\n<h1><a href='#demo' id='demo' class='anchor'></a><a href='#demo'>Demo</a></h1><p>目前，本博客的所有页面均使用了这种首屏优化策略，读者可以自行刷新页面，可以发现，没有任何异步标签被jsonp生成。</p>\n<p>实际上，所有路由都被分出去后，app.js从533KB降到了504KB（未gzip前），刚好减小了一个vue-meta的大小，博主之所有做这个优化的原因，也是因为使用了vue-meta后app.js增加的代码太多，希望能通过分块来减小打包大小。</p>\n<p>从结果来说，效果刚好达到博主的期望</p>\n<h1><a href='#流程' id='流程' class='anchor'></a><a href='#流程'>流程</a></h1><p>本文策略的流程如下</p>\n<ul>\n<li>服务器启动时将所有分块文件读进内存</li>\n<li>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</li>\n<li>根据名称获取内容后，直接和全局状态window.__INITIAL<em>STATE</em>一同写回response</li>\n<li>在客户端手动做合并分块的操作</li>\n<li>简单修改异步组件</li>\n</ul>\n<p>由于开发环境做这种首屏优化意义相当小，因为前端工程师开发时关注的并不是加载速度，所以这也是一个正式环境下独享的一种优化策略。</p>\n<h1><a href='#服务器启动时将所有分块文件读进内存' id='服务器启动时将所有分块文件读进内存' class='anchor'></a><a href='#服务器启动时将所有分块文件读进内存'>服务器启动时将所有分块文件读进内存</a></h1><p>这里判定名称数组长度为3的是分块文件，依据是本博客webpack打包时加入了hash值，格式为<code>name.[hash].js</code>。<br>如果读者没有加入hash，自行修改数组长度为2即可。</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">const</span> chunkObj = {}\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  <span class=\"hljs-keyword\">const</span> fileArr = fs.readdirSync(<span class=\"hljs-string\">'./dist'</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = fileArr.length; i &lt; len; i++) {\n    <span class=\"hljs-keyword\">const</span> fileName = fileArr[i]\n    <span class=\"hljs-keyword\">const</span> arr = fileName.split(<span class=\"hljs-string\">'.'</span>)\n    <span class=\"hljs-keyword\">if</span> (arr.length === <span class=\"hljs-number\">3</span> &amp;&amp; arr[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'app'</span>) {\n      <span class=\"hljs-keyword\">const</span> input = fs.readFileSync(<span class=\"hljs-string\">`./dist/<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">'utf-8'</span>)\n      chunkObj[fileName] = input\n    }\n  }\n}\n</code></pre>\n<h1><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' id='首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' class='anchor'></a><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称'>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></h1><p>这一步是如果不知道分块命名的话是非常难的，原因在于，System.import导入的多个异步组件时，他们的导入顺序是无序的，因为都是ES6 Module异步导入，至少博主没有发现这个顺序有算出来的办法。</p>\n<p>另外，异步组件只能在客户端中拿到分块的名称，此时导入异步组件的函数如下：</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> __webpack_require__.e<span class=\"hljs-comment\">/* import() */</span>(<span class=\"hljs-number\">4</span>).then(__webpack_require__.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">51</span>));\n}\n</code></pre>\n<p>可以使用webpack命名分块的功能来实现这一点, 我专门列了<a href=\"https://smallpath.me/post/webpack-on-demand-chunk-name\">一篇文章</a></p>\n<p>在上面这个链接的情况下, 需要定义好分块的名称</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!process.BROWSER) {\n  Post<span class=\"hljs-selector-class\">.chunkName</span> = Page<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'CreatePostView'</span>\n  TagPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'TagPager'</span>\n  Tag<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Tag'</span>\n  BlogPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'BlogPager'</span>\n  Archive<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Archive'</span>\n}\n</code></pre><h1><a href='#根据名称获取内容后，拼好html写回response' id='根据名称获取内容后，拼好html写回response' class='anchor'></a><a href='#根据名称获取内容后，拼好html写回response'>根据名称获取内容后，拼好HTML写回response</a></h1><h2><a href='#修改server-entry.js' id='修改server-entry.js' class='anchor'></a><a href='#修改server-entry.js'>修改server-entry.js</a></h2><pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">return</span> Promise.all(router.getMatchedComponents().map(<span class=\"hljs-function\"><span class=\"hljs-params\">(component, index)</span> =&gt;</span> {\n    <span class=\"hljs-regexp\">//</span> 新增如下四句\n    const chunkName = component.chunkName\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> chunkName === <span class=\"hljs-string\">'string'</span>) {\n      context.chunkName = chunkName\n    }\n    <span class=\"hljs-keyword\">if</span> (component.preFetch) {\n      <span class=\"hljs-keyword\">return</span> component.preFetch(store, context).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n  })).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(arr)</span> =&gt;</span> {\n    isDev &amp;&amp; <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">data pre-fetch: ${<span class=\"hljs-built_in\">Date</span>.now() - s}ms</span>`)\n\n    context.initialState = store.state\n    <span class=\"hljs-keyword\">return</span> realApp\n  })\n</code></pre><h2><a href='#修改renderstream的end事件' id='修改renderstream的end事件' class='anchor'></a><a href='#修改renderstream的end事件'>修改renderStream的end事件</a></h2><pre class=\"hljs\"><code>    renderStream.<span class=\"hljs-keyword\">on</span>(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (context.initialState) {\n        <span class=\"hljs-keyword\">res</span>.<span class=\"hljs-keyword\">write</span>(\n          `<span class=\"hljs-symbol\">&lt;script&gt;</span>window.__INITIAL_STATE__=${\n          JSON.stringify(context.initialState)\n          }&lt;/script&gt;`\n        )\n      }\n\n      <span class=\"hljs-keyword\">let</span> tail = html.tail\n      <span class=\"hljs-keyword\">if</span> (isProd &amp;&amp; typeof context.chunkName === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key in chunkObj) {\n          <span class=\"hljs-keyword\">if</span> (key.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>] === context.chunkName) {\n            const chunk = `&lt;script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> charset=<span class=\"hljs-string\">\"utf-8\"</span>&gt;${chunkObj[key]}&lt;/script&gt;&lt;/body&gt;`\n            tail = tail.replace(<span class=\"hljs-string\">'&lt;/body&gt;'</span>, chunk)\n            <span class=\"hljs-keyword\">break</span>\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">res</span>.end(tail)\n      <span class=\"hljs-built_in\">log</span>.<span class=\"hljs-keyword\">debug</span>(`whole reques<span class=\"hljs-variable\">t:</span> ${Date.now() - s}ms`)\n    })\n</code></pre><h1><a href='#在客户端手动做合并分块的操作' id='在客户端手动做合并分块的操作' class='anchor'></a><a href='#在客户端手动做合并分块的操作'>在客户端手动做合并分块的操作</a></h1><p>这一步也是难点，相当坑，坑死人。</p>\n<p>博主的webpack配置中，由于要使用tree-shaking来省下20KB左右的打包大小，因此没有分vendor公共块出去。</p>\n<p>如果分了vendor，那么直接把上一步生成的script标签迁移到vendor块的script标签之后和app块的script标签之前，就可以保证在vue运行前执行了我们生成好的那个分块了。</p>\n<p>但是既然没有分块，所有代码都在app.js中，那么就需要延迟vue运行，以确保app.js标签后面的我们追加的script标签内容比vue先运行</p>\n<p>否则vue-router会提前发现该组件是异步组件，然后它就自己帮我们调用webpackJsonp生成好async script标签了，这本来就是本文要避免的。</p>\n<h2><a href='#延迟app根实例的产生' id='延迟app根实例的产生' class='anchor'></a><a href='#延迟app根实例的产生'>延迟app根实例的产生</a></h2><pre class=\"hljs\"><code>const <span class=\"hljs-attr\">isProd</span> = process.env.<span class=\"hljs-attr\">NODE_ENV</span> === 'production'\n\nconst <span class=\"hljs-attr\">appOption</span> = {\n  router,\n  store,\n  ...App\n}\n\n<span class=\"hljs-keyword\">let</span> app\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-attr\">isProd</span> === <span class=\"hljs-literal\">false</span>) {\n  <span class=\"hljs-attr\">app</span> = new Vue(appOption)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">preFetchComponent</span> = [\n  Sidebar\n]\n\nexport { app, appOption, router, store, preFetchComponent, isProd }\n</code></pre><h3><a href='#在服务端生成根实例' id='在服务端生成根实例' class='anchor'></a><a href='#在服务端生成根实例'>在服务端生成根实例</a></h3><p>本文和服务端入口文件没关系，直接生成</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, preFetchComponent, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> isDev = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n</code></pre><h3><a href='#延迟客户端根实例的产生与挂载' id='延迟客户端根实例的产生与挂载' class='anchor'></a><a href='#延迟客户端根实例的产生与挂载'>延迟客户端根实例的产生与挂载</a></h3><pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> callback = isProd ? setTimeout : router.onReady.bind(router)\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">true</span>\n}\n\ncallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isProd) store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n\n  <span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__.route.hash = <span class=\"hljs-built_in\">window</span>.location.hash\n  store.replaceState(<span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__)\n  realApp.$mount(<span class=\"hljs-string\">'#app'</span>)\n})\n</code></pre><p>router.onReady为vue-router 2.2.0的新增方法，在客户端异步组件加载完时触发，我们只在开发环境调用这个回调，用来确保客户端hydrate出来的HTML和SSR出来的一致。</p>\n<p>到了正式环境，直接用setTimeout来延迟加载了。</p>\n<h1><a href='#简单修改异步组件' id='简单修改异步组件' class='anchor'></a><a href='#简单修改异步组件'>简单修改异步组件</a></h1><h2><a href='#修改全局状态' id='修改全局状态' class='anchor'></a><a href='#修改全局状态'>修改全局状态</a></h2><p>添加如下的状态</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">isLoadingAsyncComponent:</span> <span class=\"hljs-literal\">false</span>\n</code></pre><h2><a href='#对应修改异步组件' id='对应修改异步组件' class='anchor'></a><a href='#对应修改异步组件'>对应修改异步组件</a></h2><pre class=\"hljs\"><code>  preFetch: fetchAchieves,\n  beforeMount () {\n    <span class=\"hljs-keyword\">this</span>.isLoadingAsyncComponent &amp;&amp; <span class=\"hljs-keyword\">this</span>.$root._isMounted &amp;&amp; fetchAchieves(<span class=\"hljs-keyword\">this</span>.$store, <span class=\"hljs-keyword\">this</span>.$route)\n  }\n</code></pre><p>不用这个状态来标志的话，客户端组件会在SSR数据已经存在的情况下再次获取组件，造成浪费</p>\n<h2><a href='#选择性优化客户端的router钩子' id='选择性优化客户端的router钩子' class='anchor'></a><a href='#选择性优化客户端的router钩子'>选择性优化客户端的router钩子</a></h2><p>如果你使用了router的两个钩子，建议做如下处理</p>\n<h3><a href='#router.aftereach' id='router.aftereach' class='anchor'></a><a href='#router.aftereach'>router.afterEach</a></h3><pre class=\"hljs\"><code>router.afterEach((<span class=\"hljs-keyword\">to</span>, <span class=\"hljs-keyword\">from</span>) =&gt; {\n  <span class=\"hljs-comment\">// should delay it to get the correct title generated by vue-meta</span>\n  <span class=\"hljs-keyword\">from</span>.<span class=\"hljs-built_in\">name</span> &amp;&amp; clientGoogleAnalyse(<span class=\"hljs-keyword\">to</span>.path)\n})\n</code></pre><p>通过本文的延迟app挂载这种方法时，router.afterEach会在初始时被vue-router触发，博主猜测应当是vue处理异步组件后自行触发的，因此需要一个标志来避免触发。</p>\n<p>由于本博客所有路由都是具名路由，而这种触发时from.name会为null，据此可以做过滤</p>\n<h3><a href='#router.beforeeach' id='router.beforeeach' class='anchor'></a><a href='#router.beforeeach'>router.beforeEach</a></h3><p>异步组件的存在，导致数据获取的流程发生了变化，首先是异步组件被加载好，再触发异步组件的preFetch钩子进行数据获取，最后根据数据是否正常判断是否该进入路由。</p>\n<p>如果不按这个流程来，会出现新路由数据尚未获取到就进入了该组件的情况，当数据拿到时会发生一次闪屏，不仅无法控制路由，而且用户体验非常差。</p>\n<p>读者可以参考如下的数据获取流程</p>\n<pre class=\"hljs\"><code>router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 仅hash变化时，直接进入路由</span>\n  <span class=\"hljs-keyword\">if</span> (to.path === <span class=\"hljs-keyword\">from</span>.path &amp;&amp; to.hash !== <span class=\"hljs-keyword\">from</span>.hash) {\n    <span class=\"hljs-keyword\">return</span> next()\n  }\n\n  <span class=\"hljs-comment\">// Loading组件开始加载</span>\n  <span class=\"hljs-keyword\">let</span> loadingPromise = store.dispatch(<span class=\"hljs-string\">'START_LOADING'</span>)\n  <span class=\"hljs-keyword\">let</span> endLoadingCallback = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> loadingPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">interval</span> =&gt;</span> {\n      clearInterval(interval)\n      store.dispatch(<span class=\"hljs-string\">'SET_PROGRESS'</span>, <span class=\"hljs-number\">100</span>)\n      next()\n    })\n  }\n\n  <span class=\"hljs-comment\">// 根据本博客的路由定义，一定有一个组件能够被匹配到</span>\n  <span class=\"hljs-keyword\">let</span> component = router.getMatchedComponents(to.fullPath)[<span class=\"hljs-number\">0</span>]\n\n  <span class=\"hljs-comment\">// 如果是一个异步组件，我们手动resolve它，再接着调用它的preFetch接口，这样可以避免闪屏</span>\n  <span class=\"hljs-comment\">// 异步组件也是一个函数，但是它没有options这个值，可以据此做条件判断</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> component === <span class=\"hljs-string\">'function'</span> &amp;&amp; !component.options) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 一个resolve函数</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">realComponent</span> =&gt;</span> {\n        resolve(realComponent)\n      }\n      <span class=\"hljs-comment\">// 对普通异步组件来说，它会在第一层中被直接resolve，因此直接将resolve函数传给它调用</span>\n      <span class=\"hljs-keyword\">let</span> res = component(_resolve)\n      <span class=\"hljs-comment\">// 对工厂模式的组件生成函数来说，它第一层中产生的只是工厂函数，组件是在第二步中产生的</span>\n      <span class=\"hljs-comment\">// 这种工厂函数是thenable的，因此将resolve函数用then传给第二层调用</span>\n      <span class=\"hljs-keyword\">if</span> (res &amp;&amp; res.then) {\n        res.then(_resolve)\n      }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">component</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的component就是异步组件加载完毕后的真实组件了，开始调用数据获取函数</span>\n      <span class=\"hljs-keyword\">return</span> letsGo(component, store, to, endLoadingCallback)\n    })\n  }\n  <span class=\"hljs-comment\">// 调用数据获取函数</span>\n  letsGo(component, store, to, endLoadingCallback)\n})\n\n<span class=\"hljs-comment\">// 数据获取函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letsGo</span> (<span class=\"hljs-params\">component, store, to, endLoadingCallback</span>) </span>{\n  <span class=\"hljs-comment\">// 如果preFetch钩子存在，调用这个钩子，并将endLoadingCallback这个停止loading并进入路由的回调传给它</span>\n  <span class=\"hljs-keyword\">if</span> (component &amp;&amp; component.preFetch) {\n    <span class=\"hljs-keyword\">return</span> component.preFetch(store, to, endLoadingCallback).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-built_in\">Date</span>.now().toLocaleString(), err)\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 如果preFetch钩子不存在，说明这是一个静态页面，直接导航进入。</span>\n    endLoadingCallback()\n  }\n}\n</code></pre><p>这里给出preFetch的模板</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-tag\">function</span> <span class=\"hljs-selector-tag\">preFetch</span> (store, { <span class=\"hljs-attribute\">path</span>: pathName, params, query }, <span class=\"hljs-selector-tag\">callback</span>) {\n  <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">store</span><span class=\"hljs-selector-class\">.dispatch</span>(<span class=\"hljs-string\">'FETCH_TAGS'</span>, {\n    <span class=\"hljs-attribute\">model</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attribute\">query</span>: {\n      <span class=\"hljs-attribute\">conditions</span>: {\n        <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'post'</span>,\n        <span class=\"hljs-attribute\">isPublic</span>: true\n      },\n      <span class=\"hljs-attribute\">select</span>: {\n        <span class=\"hljs-attribute\">_id</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attribute\">tags</span>: <span class=\"hljs-number\">1</span>\n      }\n    },\n    callback\n  })\n}\n</code></pre><p>这种模板既能让它在SSR中被调用，又可以在客户端中被路由权限控制调用，十分有用</p>\n<p>最后，在action中手动调用callback这个参数，即可停止loading并进入路由了</p>\n<h1><a href='#结语' id='结语' class='anchor'></a><a href='#结语'>结语</a></h1><p>本文介绍的这种所有路由全部按需分块加载并完全不影响首屏速度的策略，是首屏优化中极少有人关注的。</p>\n<p>然而，它的效果十分强大，按这种策略优化首屏之后，配合SSR的SPA可以任意扩展体积与功能，并且首屏渲染将和SPA只有首屏页面时几乎一模一样。例如，本博客现在就可以毫无顾忌地开始做搜索页面了。</p>\n<p>最后，非常明显的是，本文的策略会带来一个问题，即非首屏的访问速度将会被拖慢，因为需要浏览器自行发起jsonp请求。解决办法其实也比较简单，只需要在首屏加载完成后让浏览器自行请求并缓存好对应的分块即可，这要求我们在构建时就必须得知分块的路径，并且需要搭配一个超强的请求拦截器，这也正是博主下一篇文章的内容。</p>\n"
},{
  "id": "9",
  "author": "qixin",
  "title": "9-setState 之后发生了什么 —— 浅谈 React 中的 Transaction",
  "description": "本文系对 深入理解 React 的 batchUpdate 机制 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。 之前在我的博客里有[...]",
  "pathName": "what-will-happen-after-setState-invoking-9",
  "tags": [
    "服务端渲染",
    "webpack",
    "vue",
    "性能调优",
    "Node.js",
    "express.js",
    "ES6 Module",
    "按需分块加载"
  ],
  "updatedAt": "2017-05-19 21:26:34",
  "createdAt": "2017-04-04 11:34:28",
  "toc": "<p><strong>文章目录</strong></p>\n<ul>\n<li><a href=\"#背景\">背景</a></li>\n<li><a href=\"#demo\">Demo</a></li>\n<li><a href=\"#流程\">流程</a></li>\n<li><a href=\"#服务器启动时将所有分块文件读进内存\">服务器启动时将所有分块文件读进内存</a></li>\n<li><a href=\"#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称\">首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></li>\n<li><a href=\"#根据名称获取内容后，拼好html写回response\">根据名称获取内容后，拼好HTML写回response</a><ul>\n<li><a href=\"#修改server-entry.js\">修改server-entry.js</a></li>\n<li><a href=\"#修改renderstream的end事件\">修改renderStream的end事件</a></li>\n</ul>\n</li>\n<li><a href=\"#在客户端手动做合并分块的操作\">在客户端手动做合并分块的操作</a><ul>\n<li><a href=\"#延迟app根实例的产生\">延迟app根实例的产生</a><ul>\n<li><a href=\"#在服务端生成根实例\">在服务端生成根实例</a></li>\n<li><a href=\"#延迟客户端根实例的产生与挂载\">延迟客户端根实例的产生与挂载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#简单修改异步组件\">简单修改异步组件</a><ul>\n<li><a href=\"#修改全局状态\">修改全局状态</a></li>\n<li><a href=\"#对应修改异步组件\">对应修改异步组件</a></li>\n<li><a href=\"#选择性优化客户端的router钩子\">选择性优化客户端的router钩子</a><ul>\n<li><a href=\"#router.aftereach\">router.afterEach</a></li>\n<li><a href=\"#router.beforeeach\">router.beforeEach</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#结语\">结语</a></li>\n</ul>\n",
  "html": "<p>本文介绍一种SSR与按需分块加载的首屏优化策略，可以达到将所有路由全部按需分块加载，并且完全不影响首屏速度的效果。</p>\n<h1><a href='#背景' id='背景' class='anchor'></a><a href='#背景'>背景</a></h1><p>SSR与按需分块加载，博主最初使用下来感觉其实意义有限</p>\n<p>假如全部路由都使用按需分块加载，那么首屏时间很可能不降反增，因为首屏对应的组件也同样要在客户端通过jsonp生成async script标签并异步获得。生成的标签如下：</p>\n<pre class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/dist/4.5e0b0c5a53f9c9a9cbfd.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这会严重影响首屏加载速度。</p>\n<p>假如又只有一小部分不常被访问的路由需要使用按需分块加载，那么能节省的代码量可能非常小，以博客为例，vue全家桶加一些其他的依赖占了几乎80%的体积</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.10</span>@vue: <span class=\"hljs-number\">157.97</span> KB (<span class=\"hljs-number\">39.3</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span>@vue-router: <span class=\"hljs-number\">54.82</span> KB (<span class=\"hljs-number\">13.6</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.15</span><span class=\"hljs-number\">.3</span>@axios: <span class=\"hljs-number\">35.04</span> KB (<span class=\"hljs-number\">8.72</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.5</span><span class=\"hljs-number\">.3</span>@vue-meta: <span class=\"hljs-number\">29.31</span> KB (<span class=\"hljs-number\">7.29</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>@vuex: <span class=\"hljs-number\">20.49</span> KB (<span class=\"hljs-number\">5.10</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vue-style-loader: <span class=\"hljs-number\">6.79</span> KB (<span class=\"hljs-number\">1.69</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.11</span><span class=\"hljs-number\">.9</span>@process: <span class=\"hljs-number\">5.17</span> KB (<span class=\"hljs-number\">1.29</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.25</span><span class=\"hljs-number\">.0</span>@css-loader: <span class=\"hljs-number\">1.47</span> KB (<span class=\"hljs-number\">0.366</span>%)\n<span class=\"hljs-number\">.10</span><span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span>@vue-loader: <span class=\"hljs-number\">1.09</span> KB (<span class=\"hljs-number\">0.271</span>%)\n<span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vuex-router-sync: <span class=\"hljs-number\">981</span> B (<span class=\"hljs-number\">0.238</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span>@webpack: <span class=\"hljs-number\">509</span> B (<span class=\"hljs-number\">0.124</span>%)\n&lt;self&gt;: <span class=\"hljs-number\">88.29</span> KB (<span class=\"hljs-number\">22.0</span>%)\n</code></pre><p>除非SPA自身的代码超过1M，否则那分出去的一小部分路由就只有几十KB，效果堪称鸡肋。</p>\n<p>那么，有没有一个办法，既能让所有路由全部按需分块加载，并且完全不影响首屏速度的效果呢？</p>\n<p>答案是有的，本文就是介绍如何使用SSR的服务端，来达到这样的效果。</p>\n<p>博主称之为按需分块加载的首屏优化策略</p>\n<h1><a href='#demo' id='demo' class='anchor'></a><a href='#demo'>Demo</a></h1><p>目前，本博客的所有页面均使用了这种首屏优化策略，读者可以自行刷新页面，可以发现，没有任何异步标签被jsonp生成。</p>\n<p>实际上，所有路由都被分出去后，app.js从533KB降到了504KB（未gzip前），刚好减小了一个vue-meta的大小，博主之所有做这个优化的原因，也是因为使用了vue-meta后app.js增加的代码太多，希望能通过分块来减小打包大小。</p>\n<p>从结果来说，效果刚好达到博主的期望</p>\n<h1><a href='#流程' id='流程' class='anchor'></a><a href='#流程'>流程</a></h1><p>本文策略的流程如下</p>\n<ul>\n<li>服务器启动时将所有分块文件读进内存</li>\n<li>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</li>\n<li>根据名称获取内容后，直接和全局状态window.__INITIAL<em>STATE</em>一同写回response</li>\n<li>在客户端手动做合并分块的操作</li>\n<li>简单修改异步组件</li>\n</ul>\n<p>由于开发环境做这种首屏优化意义相当小，因为前端工程师开发时关注的并不是加载速度，所以这也是一个正式环境下独享的一种优化策略。</p>\n<h1><a href='#服务器启动时将所有分块文件读进内存' id='服务器启动时将所有分块文件读进内存' class='anchor'></a><a href='#服务器启动时将所有分块文件读进内存'>服务器启动时将所有分块文件读进内存</a></h1><p>这里判定名称数组长度为3的是分块文件，依据是本博客webpack打包时加入了hash值，格式为<code>name.[hash].js</code>。<br>如果读者没有加入hash，自行修改数组长度为2即可。</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">const</span> chunkObj = {}\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  <span class=\"hljs-keyword\">const</span> fileArr = fs.readdirSync(<span class=\"hljs-string\">'./dist'</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = fileArr.length; i &lt; len; i++) {\n    <span class=\"hljs-keyword\">const</span> fileName = fileArr[i]\n    <span class=\"hljs-keyword\">const</span> arr = fileName.split(<span class=\"hljs-string\">'.'</span>)\n    <span class=\"hljs-keyword\">if</span> (arr.length === <span class=\"hljs-number\">3</span> &amp;&amp; arr[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'app'</span>) {\n      <span class=\"hljs-keyword\">const</span> input = fs.readFileSync(<span class=\"hljs-string\">`./dist/<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">'utf-8'</span>)\n      chunkObj[fileName] = input\n    }\n  }\n}\n</code></pre>\n<h1><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' id='首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' class='anchor'></a><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称'>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></h1><p>这一步是如果不知道分块命名的话是非常难的，原因在于，System.import导入的多个异步组件时，他们的导入顺序是无序的，因为都是ES6 Module异步导入，至少博主没有发现这个顺序有算出来的办法。</p>\n<p>另外，异步组件只能在客户端中拿到分块的名称，此时导入异步组件的函数如下：</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> __webpack_require__.e<span class=\"hljs-comment\">/* import() */</span>(<span class=\"hljs-number\">4</span>).then(__webpack_require__.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">51</span>));\n}\n</code></pre>\n<p>可以使用webpack命名分块的功能来实现这一点, 我专门列了<a href=\"https://smallpath.me/post/webpack-on-demand-chunk-name\">一篇文章</a></p>\n<p>在上面这个链接的情况下, 需要定义好分块的名称</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!process.BROWSER) {\n  Post<span class=\"hljs-selector-class\">.chunkName</span> = Page<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'CreatePostView'</span>\n  TagPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'TagPager'</span>\n  Tag<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Tag'</span>\n  BlogPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'BlogPager'</span>\n  Archive<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Archive'</span>\n}\n</code></pre><h1><a href='#根据名称获取内容后，拼好html写回response' id='根据名称获取内容后，拼好html写回response' class='anchor'></a><a href='#根据名称获取内容后，拼好html写回response'>根据名称获取内容后，拼好HTML写回response</a></h1><h2><a href='#修改server-entry.js' id='修改server-entry.js' class='anchor'></a><a href='#修改server-entry.js'>修改server-entry.js</a></h2><pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">return</span> Promise.all(router.getMatchedComponents().map(<span class=\"hljs-function\"><span class=\"hljs-params\">(component, index)</span> =&gt;</span> {\n    <span class=\"hljs-regexp\">//</span> 新增如下四句\n    const chunkName = component.chunkName\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> chunkName === <span class=\"hljs-string\">'string'</span>) {\n      context.chunkName = chunkName\n    }\n    <span class=\"hljs-keyword\">if</span> (component.preFetch) {\n      <span class=\"hljs-keyword\">return</span> component.preFetch(store, context).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n  })).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(arr)</span> =&gt;</span> {\n    isDev &amp;&amp; <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">data pre-fetch: ${<span class=\"hljs-built_in\">Date</span>.now() - s}ms</span>`)\n\n    context.initialState = store.state\n    <span class=\"hljs-keyword\">return</span> realApp\n  })\n</code></pre><h2><a href='#修改renderstream的end事件' id='修改renderstream的end事件' class='anchor'></a><a href='#修改renderstream的end事件'>修改renderStream的end事件</a></h2><pre class=\"hljs\"><code>    renderStream.<span class=\"hljs-keyword\">on</span>(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (context.initialState) {\n        <span class=\"hljs-keyword\">res</span>.<span class=\"hljs-keyword\">write</span>(\n          `<span class=\"hljs-symbol\">&lt;script&gt;</span>window.__INITIAL_STATE__=${\n          JSON.stringify(context.initialState)\n          }&lt;/script&gt;`\n        )\n      }\n\n      <span class=\"hljs-keyword\">let</span> tail = html.tail\n      <span class=\"hljs-keyword\">if</span> (isProd &amp;&amp; typeof context.chunkName === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key in chunkObj) {\n          <span class=\"hljs-keyword\">if</span> (key.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>] === context.chunkName) {\n            const chunk = `&lt;script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> charset=<span class=\"hljs-string\">\"utf-8\"</span>&gt;${chunkObj[key]}&lt;/script&gt;&lt;/body&gt;`\n            tail = tail.replace(<span class=\"hljs-string\">'&lt;/body&gt;'</span>, chunk)\n            <span class=\"hljs-keyword\">break</span>\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">res</span>.end(tail)\n      <span class=\"hljs-built_in\">log</span>.<span class=\"hljs-keyword\">debug</span>(`whole reques<span class=\"hljs-variable\">t:</span> ${Date.now() - s}ms`)\n    })\n</code></pre><h1><a href='#在客户端手动做合并分块的操作' id='在客户端手动做合并分块的操作' class='anchor'></a><a href='#在客户端手动做合并分块的操作'>在客户端手动做合并分块的操作</a></h1><p>这一步也是难点，相当坑，坑死人。</p>\n<p>博主的webpack配置中，由于要使用tree-shaking来省下20KB左右的打包大小，因此没有分vendor公共块出去。</p>\n<p>如果分了vendor，那么直接把上一步生成的script标签迁移到vendor块的script标签之后和app块的script标签之前，就可以保证在vue运行前执行了我们生成好的那个分块了。</p>\n<p>但是既然没有分块，所有代码都在app.js中，那么就需要延迟vue运行，以确保app.js标签后面的我们追加的script标签内容比vue先运行</p>\n<p>否则vue-router会提前发现该组件是异步组件，然后它就自己帮我们调用webpackJsonp生成好async script标签了，这本来就是本文要避免的。</p>\n<h2><a href='#延迟app根实例的产生' id='延迟app根实例的产生' class='anchor'></a><a href='#延迟app根实例的产生'>延迟app根实例的产生</a></h2><pre class=\"hljs\"><code>const <span class=\"hljs-attr\">isProd</span> = process.env.<span class=\"hljs-attr\">NODE_ENV</span> === 'production'\n\nconst <span class=\"hljs-attr\">appOption</span> = {\n  router,\n  store,\n  ...App\n}\n\n<span class=\"hljs-keyword\">let</span> app\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-attr\">isProd</span> === <span class=\"hljs-literal\">false</span>) {\n  <span class=\"hljs-attr\">app</span> = new Vue(appOption)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">preFetchComponent</span> = [\n  Sidebar\n]\n\nexport { app, appOption, router, store, preFetchComponent, isProd }\n</code></pre><h3><a href='#在服务端生成根实例' id='在服务端生成根实例' class='anchor'></a><a href='#在服务端生成根实例'>在服务端生成根实例</a></h3><p>本文和服务端入口文件没关系，直接生成</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, preFetchComponent, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> isDev = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n</code></pre><h3><a href='#延迟客户端根实例的产生与挂载' id='延迟客户端根实例的产生与挂载' class='anchor'></a><a href='#延迟客户端根实例的产生与挂载'>延迟客户端根实例的产生与挂载</a></h3><pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> callback = isProd ? setTimeout : router.onReady.bind(router)\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">true</span>\n}\n\ncallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isProd) store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n\n  <span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__.route.hash = <span class=\"hljs-built_in\">window</span>.location.hash\n  store.replaceState(<span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__)\n  realApp.$mount(<span class=\"hljs-string\">'#app'</span>)\n})\n</code></pre><p>router.onReady为vue-router 2.2.0的新增方法，在客户端异步组件加载完时触发，我们只在开发环境调用这个回调，用来确保客户端hydrate出来的HTML和SSR出来的一致。</p>\n<p>到了正式环境，直接用setTimeout来延迟加载了。</p>\n<h1><a href='#简单修改异步组件' id='简单修改异步组件' class='anchor'></a><a href='#简单修改异步组件'>简单修改异步组件</a></h1><h2><a href='#修改全局状态' id='修改全局状态' class='anchor'></a><a href='#修改全局状态'>修改全局状态</a></h2><p>添加如下的状态</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">isLoadingAsyncComponent:</span> <span class=\"hljs-literal\">false</span>\n</code></pre><h2><a href='#对应修改异步组件' id='对应修改异步组件' class='anchor'></a><a href='#对应修改异步组件'>对应修改异步组件</a></h2><pre class=\"hljs\"><code>  preFetch: fetchAchieves,\n  beforeMount () {\n    <span class=\"hljs-keyword\">this</span>.isLoadingAsyncComponent &amp;&amp; <span class=\"hljs-keyword\">this</span>.$root._isMounted &amp;&amp; fetchAchieves(<span class=\"hljs-keyword\">this</span>.$store, <span class=\"hljs-keyword\">this</span>.$route)\n  }\n</code></pre><p>不用这个状态来标志的话，客户端组件会在SSR数据已经存在的情况下再次获取组件，造成浪费</p>\n<h2><a href='#选择性优化客户端的router钩子' id='选择性优化客户端的router钩子' class='anchor'></a><a href='#选择性优化客户端的router钩子'>选择性优化客户端的router钩子</a></h2><p>如果你使用了router的两个钩子，建议做如下处理</p>\n<h3><a href='#router.aftereach' id='router.aftereach' class='anchor'></a><a href='#router.aftereach'>router.afterEach</a></h3><pre class=\"hljs\"><code>router.afterEach((<span class=\"hljs-keyword\">to</span>, <span class=\"hljs-keyword\">from</span>) =&gt; {\n  <span class=\"hljs-comment\">// should delay it to get the correct title generated by vue-meta</span>\n  <span class=\"hljs-keyword\">from</span>.<span class=\"hljs-built_in\">name</span> &amp;&amp; clientGoogleAnalyse(<span class=\"hljs-keyword\">to</span>.path)\n})\n</code></pre><p>通过本文的延迟app挂载这种方法时，router.afterEach会在初始时被vue-router触发，博主猜测应当是vue处理异步组件后自行触发的，因此需要一个标志来避免触发。</p>\n<p>由于本博客所有路由都是具名路由，而这种触发时from.name会为null，据此可以做过滤</p>\n<h3><a href='#router.beforeeach' id='router.beforeeach' class='anchor'></a><a href='#router.beforeeach'>router.beforeEach</a></h3><p>异步组件的存在，导致数据获取的流程发生了变化，首先是异步组件被加载好，再触发异步组件的preFetch钩子进行数据获取，最后根据数据是否正常判断是否该进入路由。</p>\n<p>如果不按这个流程来，会出现新路由数据尚未获取到就进入了该组件的情况，当数据拿到时会发生一次闪屏，不仅无法控制路由，而且用户体验非常差。</p>\n<p>读者可以参考如下的数据获取流程</p>\n<pre class=\"hljs\"><code>router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 仅hash变化时，直接进入路由</span>\n  <span class=\"hljs-keyword\">if</span> (to.path === <span class=\"hljs-keyword\">from</span>.path &amp;&amp; to.hash !== <span class=\"hljs-keyword\">from</span>.hash) {\n    <span class=\"hljs-keyword\">return</span> next()\n  }\n\n  <span class=\"hljs-comment\">// Loading组件开始加载</span>\n  <span class=\"hljs-keyword\">let</span> loadingPromise = store.dispatch(<span class=\"hljs-string\">'START_LOADING'</span>)\n  <span class=\"hljs-keyword\">let</span> endLoadingCallback = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> loadingPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">interval</span> =&gt;</span> {\n      clearInterval(interval)\n      store.dispatch(<span class=\"hljs-string\">'SET_PROGRESS'</span>, <span class=\"hljs-number\">100</span>)\n      next()\n    })\n  }\n\n  <span class=\"hljs-comment\">// 根据本博客的路由定义，一定有一个组件能够被匹配到</span>\n  <span class=\"hljs-keyword\">let</span> component = router.getMatchedComponents(to.fullPath)[<span class=\"hljs-number\">0</span>]\n\n  <span class=\"hljs-comment\">// 如果是一个异步组件，我们手动resolve它，再接着调用它的preFetch接口，这样可以避免闪屏</span>\n  <span class=\"hljs-comment\">// 异步组件也是一个函数，但是它没有options这个值，可以据此做条件判断</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> component === <span class=\"hljs-string\">'function'</span> &amp;&amp; !component.options) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 一个resolve函数</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">realComponent</span> =&gt;</span> {\n        resolve(realComponent)\n      }\n      <span class=\"hljs-comment\">// 对普通异步组件来说，它会在第一层中被直接resolve，因此直接将resolve函数传给它调用</span>\n      <span class=\"hljs-keyword\">let</span> res = component(_resolve)\n      <span class=\"hljs-comment\">// 对工厂模式的组件生成函数来说，它第一层中产生的只是工厂函数，组件是在第二步中产生的</span>\n      <span class=\"hljs-comment\">// 这种工厂函数是thenable的，因此将resolve函数用then传给第二层调用</span>\n      <span class=\"hljs-keyword\">if</span> (res &amp;&amp; res.then) {\n        res.then(_resolve)\n      }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">component</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的component就是异步组件加载完毕后的真实组件了，开始调用数据获取函数</span>\n      <span class=\"hljs-keyword\">return</span> letsGo(component, store, to, endLoadingCallback)\n    })\n  }\n  <span class=\"hljs-comment\">// 调用数据获取函数</span>\n  letsGo(component, store, to, endLoadingCallback)\n})\n\n<span class=\"hljs-comment\">// 数据获取函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letsGo</span> (<span class=\"hljs-params\">component, store, to, endLoadingCallback</span>) </span>{\n  <span class=\"hljs-comment\">// 如果preFetch钩子存在，调用这个钩子，并将endLoadingCallback这个停止loading并进入路由的回调传给它</span>\n  <span class=\"hljs-keyword\">if</span> (component &amp;&amp; component.preFetch) {\n    <span class=\"hljs-keyword\">return</span> component.preFetch(store, to, endLoadingCallback).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-built_in\">Date</span>.now().toLocaleString(), err)\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 如果preFetch钩子不存在，说明这是一个静态页面，直接导航进入。</span>\n    endLoadingCallback()\n  }\n}\n</code></pre><p>这里给出preFetch的模板</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-tag\">function</span> <span class=\"hljs-selector-tag\">preFetch</span> (store, { <span class=\"hljs-attribute\">path</span>: pathName, params, query }, <span class=\"hljs-selector-tag\">callback</span>) {\n  <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">store</span><span class=\"hljs-selector-class\">.dispatch</span>(<span class=\"hljs-string\">'FETCH_TAGS'</span>, {\n    <span class=\"hljs-attribute\">model</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attribute\">query</span>: {\n      <span class=\"hljs-attribute\">conditions</span>: {\n        <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'post'</span>,\n        <span class=\"hljs-attribute\">isPublic</span>: true\n      },\n      <span class=\"hljs-attribute\">select</span>: {\n        <span class=\"hljs-attribute\">_id</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attribute\">tags</span>: <span class=\"hljs-number\">1</span>\n      }\n    },\n    callback\n  })\n}\n</code></pre><p>这种模板既能让它在SSR中被调用，又可以在客户端中被路由权限控制调用，十分有用</p>\n<p>最后，在action中手动调用callback这个参数，即可停止loading并进入路由了</p>\n<h1><a href='#结语' id='结语' class='anchor'></a><a href='#结语'>结语</a></h1><p>本文介绍的这种所有路由全部按需分块加载并完全不影响首屏速度的策略，是首屏优化中极少有人关注的。</p>\n<p>然而，它的效果十分强大，按这种策略优化首屏之后，配合SSR的SPA可以任意扩展体积与功能，并且首屏渲染将和SPA只有首屏页面时几乎一模一样。例如，本博客现在就可以毫无顾忌地开始做搜索页面了。</p>\n<p>最后，非常明显的是，本文的策略会带来一个问题，即非首屏的访问速度将会被拖慢，因为需要浏览器自行发起jsonp请求。解决办法其实也比较简单，只需要在首屏加载完成后让浏览器自行请求并缓存好对应的分块即可，这要求我们在构建时就必须得知分块的路径，并且需要搭配一个超强的请求拦截器，这也正是博主下一篇文章的内容。</p>\n"
},{
  "id": "10",
  "author": "qixin",
  "title": "10-setState 之后发生了什么 —— 浅谈 React 中的 Transaction",
  "description": "本文系对 深入理解 React 的 batchUpdate 机制 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。 之前在我的博客里有[...]",
  "pathName": "what-will-happen-after-setState-invoking-10",
  "tags": [
    "服务端渲染",
    "webpack",
    "vue",
    "性能调优",
    "Node.js",
    "express.js",
    "ES6 Module",
    "按需分块加载"
  ],
  "updatedAt": "2017-05-19 21:26:34",
  "createdAt": "2017-04-04 11:34:28",
  "toc": "<p><strong>文章目录</strong></p>\n<ul>\n<li><a href=\"#背景\">背景</a></li>\n<li><a href=\"#demo\">Demo</a></li>\n<li><a href=\"#流程\">流程</a></li>\n<li><a href=\"#服务器启动时将所有分块文件读进内存\">服务器启动时将所有分块文件读进内存</a></li>\n<li><a href=\"#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称\">首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></li>\n<li><a href=\"#根据名称获取内容后，拼好html写回response\">根据名称获取内容后，拼好HTML写回response</a><ul>\n<li><a href=\"#修改server-entry.js\">修改server-entry.js</a></li>\n<li><a href=\"#修改renderstream的end事件\">修改renderStream的end事件</a></li>\n</ul>\n</li>\n<li><a href=\"#在客户端手动做合并分块的操作\">在客户端手动做合并分块的操作</a><ul>\n<li><a href=\"#延迟app根实例的产生\">延迟app根实例的产生</a><ul>\n<li><a href=\"#在服务端生成根实例\">在服务端生成根实例</a></li>\n<li><a href=\"#延迟客户端根实例的产生与挂载\">延迟客户端根实例的产生与挂载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#简单修改异步组件\">简单修改异步组件</a><ul>\n<li><a href=\"#修改全局状态\">修改全局状态</a></li>\n<li><a href=\"#对应修改异步组件\">对应修改异步组件</a></li>\n<li><a href=\"#选择性优化客户端的router钩子\">选择性优化客户端的router钩子</a><ul>\n<li><a href=\"#router.aftereach\">router.afterEach</a></li>\n<li><a href=\"#router.beforeeach\">router.beforeEach</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#结语\">结语</a></li>\n</ul>\n",
  "html": "<p>本文介绍一种SSR与按需分块加载的首屏优化策略，可以达到将所有路由全部按需分块加载，并且完全不影响首屏速度的效果。</p>\n<h1><a href='#背景' id='背景' class='anchor'></a><a href='#背景'>背景</a></h1><p>SSR与按需分块加载，博主最初使用下来感觉其实意义有限</p>\n<p>假如全部路由都使用按需分块加载，那么首屏时间很可能不降反增，因为首屏对应的组件也同样要在客户端通过jsonp生成async script标签并异步获得。生成的标签如下：</p>\n<pre class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/dist/4.5e0b0c5a53f9c9a9cbfd.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这会严重影响首屏加载速度。</p>\n<p>假如又只有一小部分不常被访问的路由需要使用按需分块加载，那么能节省的代码量可能非常小，以博客为例，vue全家桶加一些其他的依赖占了几乎80%的体积</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.10</span>@vue: <span class=\"hljs-number\">157.97</span> KB (<span class=\"hljs-number\">39.3</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span>@vue-router: <span class=\"hljs-number\">54.82</span> KB (<span class=\"hljs-number\">13.6</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.15</span><span class=\"hljs-number\">.3</span>@axios: <span class=\"hljs-number\">35.04</span> KB (<span class=\"hljs-number\">8.72</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.5</span><span class=\"hljs-number\">.3</span>@vue-meta: <span class=\"hljs-number\">29.31</span> KB (<span class=\"hljs-number\">7.29</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>@vuex: <span class=\"hljs-number\">20.49</span> KB (<span class=\"hljs-number\">5.10</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vue-style-loader: <span class=\"hljs-number\">6.79</span> KB (<span class=\"hljs-number\">1.69</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.11</span><span class=\"hljs-number\">.9</span>@process: <span class=\"hljs-number\">5.17</span> KB (<span class=\"hljs-number\">1.29</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.25</span><span class=\"hljs-number\">.0</span>@css-loader: <span class=\"hljs-number\">1.47</span> KB (<span class=\"hljs-number\">0.366</span>%)\n<span class=\"hljs-number\">.10</span><span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span>@vue-loader: <span class=\"hljs-number\">1.09</span> KB (<span class=\"hljs-number\">0.271</span>%)\n<span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vuex-router-sync: <span class=\"hljs-number\">981</span> B (<span class=\"hljs-number\">0.238</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span>@webpack: <span class=\"hljs-number\">509</span> B (<span class=\"hljs-number\">0.124</span>%)\n&lt;self&gt;: <span class=\"hljs-number\">88.29</span> KB (<span class=\"hljs-number\">22.0</span>%)\n</code></pre><p>除非SPA自身的代码超过1M，否则那分出去的一小部分路由就只有几十KB，效果堪称鸡肋。</p>\n<p>那么，有没有一个办法，既能让所有路由全部按需分块加载，并且完全不影响首屏速度的效果呢？</p>\n<p>答案是有的，本文就是介绍如何使用SSR的服务端，来达到这样的效果。</p>\n<p>博主称之为按需分块加载的首屏优化策略</p>\n<h1><a href='#demo' id='demo' class='anchor'></a><a href='#demo'>Demo</a></h1><p>目前，本博客的所有页面均使用了这种首屏优化策略，读者可以自行刷新页面，可以发现，没有任何异步标签被jsonp生成。</p>\n<p>实际上，所有路由都被分出去后，app.js从533KB降到了504KB（未gzip前），刚好减小了一个vue-meta的大小，博主之所有做这个优化的原因，也是因为使用了vue-meta后app.js增加的代码太多，希望能通过分块来减小打包大小。</p>\n<p>从结果来说，效果刚好达到博主的期望</p>\n<h1><a href='#流程' id='流程' class='anchor'></a><a href='#流程'>流程</a></h1><p>本文策略的流程如下</p>\n<ul>\n<li>服务器启动时将所有分块文件读进内存</li>\n<li>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</li>\n<li>根据名称获取内容后，直接和全局状态window.__INITIAL<em>STATE</em>一同写回response</li>\n<li>在客户端手动做合并分块的操作</li>\n<li>简单修改异步组件</li>\n</ul>\n<p>由于开发环境做这种首屏优化意义相当小，因为前端工程师开发时关注的并不是加载速度，所以这也是一个正式环境下独享的一种优化策略。</p>\n<h1><a href='#服务器启动时将所有分块文件读进内存' id='服务器启动时将所有分块文件读进内存' class='anchor'></a><a href='#服务器启动时将所有分块文件读进内存'>服务器启动时将所有分块文件读进内存</a></h1><p>这里判定名称数组长度为3的是分块文件，依据是本博客webpack打包时加入了hash值，格式为<code>name.[hash].js</code>。<br>如果读者没有加入hash，自行修改数组长度为2即可。</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">const</span> chunkObj = {}\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  <span class=\"hljs-keyword\">const</span> fileArr = fs.readdirSync(<span class=\"hljs-string\">'./dist'</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = fileArr.length; i &lt; len; i++) {\n    <span class=\"hljs-keyword\">const</span> fileName = fileArr[i]\n    <span class=\"hljs-keyword\">const</span> arr = fileName.split(<span class=\"hljs-string\">'.'</span>)\n    <span class=\"hljs-keyword\">if</span> (arr.length === <span class=\"hljs-number\">3</span> &amp;&amp; arr[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'app'</span>) {\n      <span class=\"hljs-keyword\">const</span> input = fs.readFileSync(<span class=\"hljs-string\">`./dist/<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">'utf-8'</span>)\n      chunkObj[fileName] = input\n    }\n  }\n}\n</code></pre>\n<h1><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' id='首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' class='anchor'></a><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称'>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></h1><p>这一步是如果不知道分块命名的话是非常难的，原因在于，System.import导入的多个异步组件时，他们的导入顺序是无序的，因为都是ES6 Module异步导入，至少博主没有发现这个顺序有算出来的办法。</p>\n<p>另外，异步组件只能在客户端中拿到分块的名称，此时导入异步组件的函数如下：</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> __webpack_require__.e<span class=\"hljs-comment\">/* import() */</span>(<span class=\"hljs-number\">4</span>).then(__webpack_require__.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">51</span>));\n}\n</code></pre>\n<p>可以使用webpack命名分块的功能来实现这一点, 我专门列了<a href=\"https://smallpath.me/post/webpack-on-demand-chunk-name\">一篇文章</a></p>\n<p>在上面这个链接的情况下, 需要定义好分块的名称</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!process.BROWSER) {\n  Post<span class=\"hljs-selector-class\">.chunkName</span> = Page<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'CreatePostView'</span>\n  TagPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'TagPager'</span>\n  Tag<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Tag'</span>\n  BlogPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'BlogPager'</span>\n  Archive<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Archive'</span>\n}\n</code></pre><h1><a href='#根据名称获取内容后，拼好html写回response' id='根据名称获取内容后，拼好html写回response' class='anchor'></a><a href='#根据名称获取内容后，拼好html写回response'>根据名称获取内容后，拼好HTML写回response</a></h1><h2><a href='#修改server-entry.js' id='修改server-entry.js' class='anchor'></a><a href='#修改server-entry.js'>修改server-entry.js</a></h2><pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">return</span> Promise.all(router.getMatchedComponents().map(<span class=\"hljs-function\"><span class=\"hljs-params\">(component, index)</span> =&gt;</span> {\n    <span class=\"hljs-regexp\">//</span> 新增如下四句\n    const chunkName = component.chunkName\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> chunkName === <span class=\"hljs-string\">'string'</span>) {\n      context.chunkName = chunkName\n    }\n    <span class=\"hljs-keyword\">if</span> (component.preFetch) {\n      <span class=\"hljs-keyword\">return</span> component.preFetch(store, context).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n  })).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(arr)</span> =&gt;</span> {\n    isDev &amp;&amp; <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">data pre-fetch: ${<span class=\"hljs-built_in\">Date</span>.now() - s}ms</span>`)\n\n    context.initialState = store.state\n    <span class=\"hljs-keyword\">return</span> realApp\n  })\n</code></pre><h2><a href='#修改renderstream的end事件' id='修改renderstream的end事件' class='anchor'></a><a href='#修改renderstream的end事件'>修改renderStream的end事件</a></h2><pre class=\"hljs\"><code>    renderStream.<span class=\"hljs-keyword\">on</span>(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (context.initialState) {\n        <span class=\"hljs-keyword\">res</span>.<span class=\"hljs-keyword\">write</span>(\n          `<span class=\"hljs-symbol\">&lt;script&gt;</span>window.__INITIAL_STATE__=${\n          JSON.stringify(context.initialState)\n          }&lt;/script&gt;`\n        )\n      }\n\n      <span class=\"hljs-keyword\">let</span> tail = html.tail\n      <span class=\"hljs-keyword\">if</span> (isProd &amp;&amp; typeof context.chunkName === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key in chunkObj) {\n          <span class=\"hljs-keyword\">if</span> (key.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>] === context.chunkName) {\n            const chunk = `&lt;script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> charset=<span class=\"hljs-string\">\"utf-8\"</span>&gt;${chunkObj[key]}&lt;/script&gt;&lt;/body&gt;`\n            tail = tail.replace(<span class=\"hljs-string\">'&lt;/body&gt;'</span>, chunk)\n            <span class=\"hljs-keyword\">break</span>\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">res</span>.end(tail)\n      <span class=\"hljs-built_in\">log</span>.<span class=\"hljs-keyword\">debug</span>(`whole reques<span class=\"hljs-variable\">t:</span> ${Date.now() - s}ms`)\n    })\n</code></pre><h1><a href='#在客户端手动做合并分块的操作' id='在客户端手动做合并分块的操作' class='anchor'></a><a href='#在客户端手动做合并分块的操作'>在客户端手动做合并分块的操作</a></h1><p>这一步也是难点，相当坑，坑死人。</p>\n<p>博主的webpack配置中，由于要使用tree-shaking来省下20KB左右的打包大小，因此没有分vendor公共块出去。</p>\n<p>如果分了vendor，那么直接把上一步生成的script标签迁移到vendor块的script标签之后和app块的script标签之前，就可以保证在vue运行前执行了我们生成好的那个分块了。</p>\n<p>但是既然没有分块，所有代码都在app.js中，那么就需要延迟vue运行，以确保app.js标签后面的我们追加的script标签内容比vue先运行</p>\n<p>否则vue-router会提前发现该组件是异步组件，然后它就自己帮我们调用webpackJsonp生成好async script标签了，这本来就是本文要避免的。</p>\n<h2><a href='#延迟app根实例的产生' id='延迟app根实例的产生' class='anchor'></a><a href='#延迟app根实例的产生'>延迟app根实例的产生</a></h2><pre class=\"hljs\"><code>const <span class=\"hljs-attr\">isProd</span> = process.env.<span class=\"hljs-attr\">NODE_ENV</span> === 'production'\n\nconst <span class=\"hljs-attr\">appOption</span> = {\n  router,\n  store,\n  ...App\n}\n\n<span class=\"hljs-keyword\">let</span> app\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-attr\">isProd</span> === <span class=\"hljs-literal\">false</span>) {\n  <span class=\"hljs-attr\">app</span> = new Vue(appOption)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">preFetchComponent</span> = [\n  Sidebar\n]\n\nexport { app, appOption, router, store, preFetchComponent, isProd }\n</code></pre><h3><a href='#在服务端生成根实例' id='在服务端生成根实例' class='anchor'></a><a href='#在服务端生成根实例'>在服务端生成根实例</a></h3><p>本文和服务端入口文件没关系，直接生成</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, preFetchComponent, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> isDev = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n</code></pre><h3><a href='#延迟客户端根实例的产生与挂载' id='延迟客户端根实例的产生与挂载' class='anchor'></a><a href='#延迟客户端根实例的产生与挂载'>延迟客户端根实例的产生与挂载</a></h3><pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> callback = isProd ? setTimeout : router.onReady.bind(router)\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">true</span>\n}\n\ncallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isProd) store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n\n  <span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__.route.hash = <span class=\"hljs-built_in\">window</span>.location.hash\n  store.replaceState(<span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__)\n  realApp.$mount(<span class=\"hljs-string\">'#app'</span>)\n})\n</code></pre><p>router.onReady为vue-router 2.2.0的新增方法，在客户端异步组件加载完时触发，我们只在开发环境调用这个回调，用来确保客户端hydrate出来的HTML和SSR出来的一致。</p>\n<p>到了正式环境，直接用setTimeout来延迟加载了。</p>\n<h1><a href='#简单修改异步组件' id='简单修改异步组件' class='anchor'></a><a href='#简单修改异步组件'>简单修改异步组件</a></h1><h2><a href='#修改全局状态' id='修改全局状态' class='anchor'></a><a href='#修改全局状态'>修改全局状态</a></h2><p>添加如下的状态</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">isLoadingAsyncComponent:</span> <span class=\"hljs-literal\">false</span>\n</code></pre><h2><a href='#对应修改异步组件' id='对应修改异步组件' class='anchor'></a><a href='#对应修改异步组件'>对应修改异步组件</a></h2><pre class=\"hljs\"><code>  preFetch: fetchAchieves,\n  beforeMount () {\n    <span class=\"hljs-keyword\">this</span>.isLoadingAsyncComponent &amp;&amp; <span class=\"hljs-keyword\">this</span>.$root._isMounted &amp;&amp; fetchAchieves(<span class=\"hljs-keyword\">this</span>.$store, <span class=\"hljs-keyword\">this</span>.$route)\n  }\n</code></pre><p>不用这个状态来标志的话，客户端组件会在SSR数据已经存在的情况下再次获取组件，造成浪费</p>\n<h2><a href='#选择性优化客户端的router钩子' id='选择性优化客户端的router钩子' class='anchor'></a><a href='#选择性优化客户端的router钩子'>选择性优化客户端的router钩子</a></h2><p>如果你使用了router的两个钩子，建议做如下处理</p>\n<h3><a href='#router.aftereach' id='router.aftereach' class='anchor'></a><a href='#router.aftereach'>router.afterEach</a></h3><pre class=\"hljs\"><code>router.afterEach((<span class=\"hljs-keyword\">to</span>, <span class=\"hljs-keyword\">from</span>) =&gt; {\n  <span class=\"hljs-comment\">// should delay it to get the correct title generated by vue-meta</span>\n  <span class=\"hljs-keyword\">from</span>.<span class=\"hljs-built_in\">name</span> &amp;&amp; clientGoogleAnalyse(<span class=\"hljs-keyword\">to</span>.path)\n})\n</code></pre><p>通过本文的延迟app挂载这种方法时，router.afterEach会在初始时被vue-router触发，博主猜测应当是vue处理异步组件后自行触发的，因此需要一个标志来避免触发。</p>\n<p>由于本博客所有路由都是具名路由，而这种触发时from.name会为null，据此可以做过滤</p>\n<h3><a href='#router.beforeeach' id='router.beforeeach' class='anchor'></a><a href='#router.beforeeach'>router.beforeEach</a></h3><p>异步组件的存在，导致数据获取的流程发生了变化，首先是异步组件被加载好，再触发异步组件的preFetch钩子进行数据获取，最后根据数据是否正常判断是否该进入路由。</p>\n<p>如果不按这个流程来，会出现新路由数据尚未获取到就进入了该组件的情况，当数据拿到时会发生一次闪屏，不仅无法控制路由，而且用户体验非常差。</p>\n<p>读者可以参考如下的数据获取流程</p>\n<pre class=\"hljs\"><code>router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 仅hash变化时，直接进入路由</span>\n  <span class=\"hljs-keyword\">if</span> (to.path === <span class=\"hljs-keyword\">from</span>.path &amp;&amp; to.hash !== <span class=\"hljs-keyword\">from</span>.hash) {\n    <span class=\"hljs-keyword\">return</span> next()\n  }\n\n  <span class=\"hljs-comment\">// Loading组件开始加载</span>\n  <span class=\"hljs-keyword\">let</span> loadingPromise = store.dispatch(<span class=\"hljs-string\">'START_LOADING'</span>)\n  <span class=\"hljs-keyword\">let</span> endLoadingCallback = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> loadingPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">interval</span> =&gt;</span> {\n      clearInterval(interval)\n      store.dispatch(<span class=\"hljs-string\">'SET_PROGRESS'</span>, <span class=\"hljs-number\">100</span>)\n      next()\n    })\n  }\n\n  <span class=\"hljs-comment\">// 根据本博客的路由定义，一定有一个组件能够被匹配到</span>\n  <span class=\"hljs-keyword\">let</span> component = router.getMatchedComponents(to.fullPath)[<span class=\"hljs-number\">0</span>]\n\n  <span class=\"hljs-comment\">// 如果是一个异步组件，我们手动resolve它，再接着调用它的preFetch接口，这样可以避免闪屏</span>\n  <span class=\"hljs-comment\">// 异步组件也是一个函数，但是它没有options这个值，可以据此做条件判断</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> component === <span class=\"hljs-string\">'function'</span> &amp;&amp; !component.options) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 一个resolve函数</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">realComponent</span> =&gt;</span> {\n        resolve(realComponent)\n      }\n      <span class=\"hljs-comment\">// 对普通异步组件来说，它会在第一层中被直接resolve，因此直接将resolve函数传给它调用</span>\n      <span class=\"hljs-keyword\">let</span> res = component(_resolve)\n      <span class=\"hljs-comment\">// 对工厂模式的组件生成函数来说，它第一层中产生的只是工厂函数，组件是在第二步中产生的</span>\n      <span class=\"hljs-comment\">// 这种工厂函数是thenable的，因此将resolve函数用then传给第二层调用</span>\n      <span class=\"hljs-keyword\">if</span> (res &amp;&amp; res.then) {\n        res.then(_resolve)\n      }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">component</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的component就是异步组件加载完毕后的真实组件了，开始调用数据获取函数</span>\n      <span class=\"hljs-keyword\">return</span> letsGo(component, store, to, endLoadingCallback)\n    })\n  }\n  <span class=\"hljs-comment\">// 调用数据获取函数</span>\n  letsGo(component, store, to, endLoadingCallback)\n})\n\n<span class=\"hljs-comment\">// 数据获取函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letsGo</span> (<span class=\"hljs-params\">component, store, to, endLoadingCallback</span>) </span>{\n  <span class=\"hljs-comment\">// 如果preFetch钩子存在，调用这个钩子，并将endLoadingCallback这个停止loading并进入路由的回调传给它</span>\n  <span class=\"hljs-keyword\">if</span> (component &amp;&amp; component.preFetch) {\n    <span class=\"hljs-keyword\">return</span> component.preFetch(store, to, endLoadingCallback).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-built_in\">Date</span>.now().toLocaleString(), err)\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 如果preFetch钩子不存在，说明这是一个静态页面，直接导航进入。</span>\n    endLoadingCallback()\n  }\n}\n</code></pre><p>这里给出preFetch的模板</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-tag\">function</span> <span class=\"hljs-selector-tag\">preFetch</span> (store, { <span class=\"hljs-attribute\">path</span>: pathName, params, query }, <span class=\"hljs-selector-tag\">callback</span>) {\n  <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">store</span><span class=\"hljs-selector-class\">.dispatch</span>(<span class=\"hljs-string\">'FETCH_TAGS'</span>, {\n    <span class=\"hljs-attribute\">model</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attribute\">query</span>: {\n      <span class=\"hljs-attribute\">conditions</span>: {\n        <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'post'</span>,\n        <span class=\"hljs-attribute\">isPublic</span>: true\n      },\n      <span class=\"hljs-attribute\">select</span>: {\n        <span class=\"hljs-attribute\">_id</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attribute\">tags</span>: <span class=\"hljs-number\">1</span>\n      }\n    },\n    callback\n  })\n}\n</code></pre><p>这种模板既能让它在SSR中被调用，又可以在客户端中被路由权限控制调用，十分有用</p>\n<p>最后，在action中手动调用callback这个参数，即可停止loading并进入路由了</p>\n<h1><a href='#结语' id='结语' class='anchor'></a><a href='#结语'>结语</a></h1><p>本文介绍的这种所有路由全部按需分块加载并完全不影响首屏速度的策略，是首屏优化中极少有人关注的。</p>\n<p>然而，它的效果十分强大，按这种策略优化首屏之后，配合SSR的SPA可以任意扩展体积与功能，并且首屏渲染将和SPA只有首屏页面时几乎一模一样。例如，本博客现在就可以毫无顾忌地开始做搜索页面了。</p>\n<p>最后，非常明显的是，本文的策略会带来一个问题，即非首屏的访问速度将会被拖慢，因为需要浏览器自行发起jsonp请求。解决办法其实也比较简单，只需要在首屏加载完成后让浏览器自行请求并缓存好对应的分块即可，这要求我们在构建时就必须得知分块的路径，并且需要搭配一个超强的请求拦截器，这也正是博主下一篇文章的内容。</p>\n"
},{
  "id": "11",
  "author": "qixin",
  "title": "11-setState 之后发生了什么 —— 浅谈 React 中的 Transaction",
  "description": "本文系对 深入理解 React 的 batchUpdate 机制 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。 之前在我的博客里有[...]",
  "pathName": "what-will-happen-after-setState-invoking-11",
  "tags": [
    "服务端渲染",
    "webpack",
    "vue",
    "性能调优",
    "Node.js",
    "express.js",
    "ES6 Module",
    "按需分块加载"
  ],
  "updatedAt": "2017-05-19 21:26:34",
  "createdAt": "2017-04-04 11:34:28",
  "toc": "<p><strong>文章目录</strong></p>\n<ul>\n<li><a href=\"#背景\">背景</a></li>\n<li><a href=\"#demo\">Demo</a></li>\n<li><a href=\"#流程\">流程</a></li>\n<li><a href=\"#服务器启动时将所有分块文件读进内存\">服务器启动时将所有分块文件读进内存</a></li>\n<li><a href=\"#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称\">首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></li>\n<li><a href=\"#根据名称获取内容后，拼好html写回response\">根据名称获取内容后，拼好HTML写回response</a><ul>\n<li><a href=\"#修改server-entry.js\">修改server-entry.js</a></li>\n<li><a href=\"#修改renderstream的end事件\">修改renderStream的end事件</a></li>\n</ul>\n</li>\n<li><a href=\"#在客户端手动做合并分块的操作\">在客户端手动做合并分块的操作</a><ul>\n<li><a href=\"#延迟app根实例的产生\">延迟app根实例的产生</a><ul>\n<li><a href=\"#在服务端生成根实例\">在服务端生成根实例</a></li>\n<li><a href=\"#延迟客户端根实例的产生与挂载\">延迟客户端根实例的产生与挂载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#简单修改异步组件\">简单修改异步组件</a><ul>\n<li><a href=\"#修改全局状态\">修改全局状态</a></li>\n<li><a href=\"#对应修改异步组件\">对应修改异步组件</a></li>\n<li><a href=\"#选择性优化客户端的router钩子\">选择性优化客户端的router钩子</a><ul>\n<li><a href=\"#router.aftereach\">router.afterEach</a></li>\n<li><a href=\"#router.beforeeach\">router.beforeEach</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#结语\">结语</a></li>\n</ul>\n",
  "html": "<p>本文介绍一种SSR与按需分块加载的首屏优化策略，可以达到将所有路由全部按需分块加载，并且完全不影响首屏速度的效果。</p>\n<h1><a href='#背景' id='背景' class='anchor'></a><a href='#背景'>背景</a></h1><p>SSR与按需分块加载，博主最初使用下来感觉其实意义有限</p>\n<p>假如全部路由都使用按需分块加载，那么首屏时间很可能不降反增，因为首屏对应的组件也同样要在客户端通过jsonp生成async script标签并异步获得。生成的标签如下：</p>\n<pre class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/dist/4.5e0b0c5a53f9c9a9cbfd.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这会严重影响首屏加载速度。</p>\n<p>假如又只有一小部分不常被访问的路由需要使用按需分块加载，那么能节省的代码量可能非常小，以博客为例，vue全家桶加一些其他的依赖占了几乎80%的体积</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.10</span>@vue: <span class=\"hljs-number\">157.97</span> KB (<span class=\"hljs-number\">39.3</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span>@vue-router: <span class=\"hljs-number\">54.82</span> KB (<span class=\"hljs-number\">13.6</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.15</span><span class=\"hljs-number\">.3</span>@axios: <span class=\"hljs-number\">35.04</span> KB (<span class=\"hljs-number\">8.72</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.5</span><span class=\"hljs-number\">.3</span>@vue-meta: <span class=\"hljs-number\">29.31</span> KB (<span class=\"hljs-number\">7.29</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.1</span>@vuex: <span class=\"hljs-number\">20.49</span> KB (<span class=\"hljs-number\">5.10</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vue-style-loader: <span class=\"hljs-number\">6.79</span> KB (<span class=\"hljs-number\">1.69</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.11</span><span class=\"hljs-number\">.9</span>@process: <span class=\"hljs-number\">5.17</span> KB (<span class=\"hljs-number\">1.29</span>%)\n<span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.25</span><span class=\"hljs-number\">.0</span>@css-loader: <span class=\"hljs-number\">1.47</span> KB (<span class=\"hljs-number\">0.366</span>%)\n<span class=\"hljs-number\">.10</span><span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span>@vue-loader: <span class=\"hljs-number\">1.09</span> KB (<span class=\"hljs-number\">0.271</span>%)\n<span class=\"hljs-number\">.3</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>@vuex-router-sync: <span class=\"hljs-number\">981</span> B (<span class=\"hljs-number\">0.238</span>%)\n<span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.2</span><span class=\"hljs-number\">.1</span>@webpack: <span class=\"hljs-number\">509</span> B (<span class=\"hljs-number\">0.124</span>%)\n&lt;self&gt;: <span class=\"hljs-number\">88.29</span> KB (<span class=\"hljs-number\">22.0</span>%)\n</code></pre><p>除非SPA自身的代码超过1M，否则那分出去的一小部分路由就只有几十KB，效果堪称鸡肋。</p>\n<p>那么，有没有一个办法，既能让所有路由全部按需分块加载，并且完全不影响首屏速度的效果呢？</p>\n<p>答案是有的，本文就是介绍如何使用SSR的服务端，来达到这样的效果。</p>\n<p>博主称之为按需分块加载的首屏优化策略</p>\n<h1><a href='#demo' id='demo' class='anchor'></a><a href='#demo'>Demo</a></h1><p>目前，本博客的所有页面均使用了这种首屏优化策略，读者可以自行刷新页面，可以发现，没有任何异步标签被jsonp生成。</p>\n<p>实际上，所有路由都被分出去后，app.js从533KB降到了504KB（未gzip前），刚好减小了一个vue-meta的大小，博主之所有做这个优化的原因，也是因为使用了vue-meta后app.js增加的代码太多，希望能通过分块来减小打包大小。</p>\n<p>从结果来说，效果刚好达到博主的期望</p>\n<h1><a href='#流程' id='流程' class='anchor'></a><a href='#流程'>流程</a></h1><p>本文策略的流程如下</p>\n<ul>\n<li>服务器启动时将所有分块文件读进内存</li>\n<li>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</li>\n<li>根据名称获取内容后，直接和全局状态window.__INITIAL<em>STATE</em>一同写回response</li>\n<li>在客户端手动做合并分块的操作</li>\n<li>简单修改异步组件</li>\n</ul>\n<p>由于开发环境做这种首屏优化意义相当小，因为前端工程师开发时关注的并不是加载速度，所以这也是一个正式环境下独享的一种优化策略。</p>\n<h1><a href='#服务器启动时将所有分块文件读进内存' id='服务器启动时将所有分块文件读进内存' class='anchor'></a><a href='#服务器启动时将所有分块文件读进内存'>服务器启动时将所有分块文件读进内存</a></h1><p>这里判定名称数组长度为3的是分块文件，依据是本博客webpack打包时加入了hash值，格式为<code>name.[hash].js</code>。<br>如果读者没有加入hash，自行修改数组长度为2即可。</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> isProd = process.env.NODE_ENV === <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">const</span> chunkObj = {}\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  <span class=\"hljs-keyword\">const</span> fileArr = fs.readdirSync(<span class=\"hljs-string\">'./dist'</span>)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = fileArr.length; i &lt; len; i++) {\n    <span class=\"hljs-keyword\">const</span> fileName = fileArr[i]\n    <span class=\"hljs-keyword\">const</span> arr = fileName.split(<span class=\"hljs-string\">'.'</span>)\n    <span class=\"hljs-keyword\">if</span> (arr.length === <span class=\"hljs-number\">3</span> &amp;&amp; arr[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'app'</span>) {\n      <span class=\"hljs-keyword\">const</span> input = fs.readFileSync(<span class=\"hljs-string\">`./dist/<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">'utf-8'</span>)\n      chunkObj[fileName] = input\n    }\n  }\n}\n</code></pre>\n<h1><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' id='首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称' class='anchor'></a><a href='#首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称'>首屏访问时解析路由对应的组件，拿到该组件被分块出去的文件名称</a></h1><p>这一步是如果不知道分块命名的话是非常难的，原因在于，System.import导入的多个异步组件时，他们的导入顺序是无序的，因为都是ES6 Module异步导入，至少博主没有发现这个顺序有算出来的办法。</p>\n<p>另外，异步组件只能在客户端中拿到分块的名称，此时导入异步组件的函数如下：</p>\n<pre class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> __webpack_require__.e<span class=\"hljs-comment\">/* import() */</span>(<span class=\"hljs-number\">4</span>).then(__webpack_require__.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">51</span>));\n}\n</code></pre>\n<p>可以使用webpack命名分块的功能来实现这一点, 我专门列了<a href=\"https://smallpath.me/post/webpack-on-demand-chunk-name\">一篇文章</a></p>\n<p>在上面这个链接的情况下, 需要定义好分块的名称</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">if</span> (!process.BROWSER) {\n  Post<span class=\"hljs-selector-class\">.chunkName</span> = Page<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'CreatePostView'</span>\n  TagPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'TagPager'</span>\n  Tag<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Tag'</span>\n  BlogPager<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'BlogPager'</span>\n  Archive<span class=\"hljs-selector-class\">.chunkName</span> = <span class=\"hljs-string\">'Archive'</span>\n}\n</code></pre><h1><a href='#根据名称获取内容后，拼好html写回response' id='根据名称获取内容后，拼好html写回response' class='anchor'></a><a href='#根据名称获取内容后，拼好html写回response'>根据名称获取内容后，拼好HTML写回response</a></h1><h2><a href='#修改server-entry.js' id='修改server-entry.js' class='anchor'></a><a href='#修改server-entry.js'>修改server-entry.js</a></h2><pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">return</span> Promise.all(router.getMatchedComponents().map(<span class=\"hljs-function\"><span class=\"hljs-params\">(component, index)</span> =&gt;</span> {\n    <span class=\"hljs-regexp\">//</span> 新增如下四句\n    const chunkName = component.chunkName\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> chunkName === <span class=\"hljs-string\">'string'</span>) {\n      context.chunkName = chunkName\n    }\n    <span class=\"hljs-keyword\">if</span> (component.preFetch) {\n      <span class=\"hljs-keyword\">return</span> component.preFetch(store, context).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {})\n    }\n  })).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(arr)</span> =&gt;</span> {\n    isDev &amp;&amp; <span class=\"hljs-built_in\">console</span>.log(`<span class=\"javascript\">data pre-fetch: ${<span class=\"hljs-built_in\">Date</span>.now() - s}ms</span>`)\n\n    context.initialState = store.state\n    <span class=\"hljs-keyword\">return</span> realApp\n  })\n</code></pre><h2><a href='#修改renderstream的end事件' id='修改renderstream的end事件' class='anchor'></a><a href='#修改renderstream的end事件'>修改renderStream的end事件</a></h2><pre class=\"hljs\"><code>    renderStream.<span class=\"hljs-keyword\">on</span>(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (context.initialState) {\n        <span class=\"hljs-keyword\">res</span>.<span class=\"hljs-keyword\">write</span>(\n          `<span class=\"hljs-symbol\">&lt;script&gt;</span>window.__INITIAL_STATE__=${\n          JSON.stringify(context.initialState)\n          }&lt;/script&gt;`\n        )\n      }\n\n      <span class=\"hljs-keyword\">let</span> tail = html.tail\n      <span class=\"hljs-keyword\">if</span> (isProd &amp;&amp; typeof context.chunkName === <span class=\"hljs-string\">'string'</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key in chunkObj) {\n          <span class=\"hljs-keyword\">if</span> (key.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>] === context.chunkName) {\n            const chunk = `&lt;script <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> charset=<span class=\"hljs-string\">\"utf-8\"</span>&gt;${chunkObj[key]}&lt;/script&gt;&lt;/body&gt;`\n            tail = tail.replace(<span class=\"hljs-string\">'&lt;/body&gt;'</span>, chunk)\n            <span class=\"hljs-keyword\">break</span>\n          }\n        }\n      }\n\n      <span class=\"hljs-keyword\">res</span>.end(tail)\n      <span class=\"hljs-built_in\">log</span>.<span class=\"hljs-keyword\">debug</span>(`whole reques<span class=\"hljs-variable\">t:</span> ${Date.now() - s}ms`)\n    })\n</code></pre><h1><a href='#在客户端手动做合并分块的操作' id='在客户端手动做合并分块的操作' class='anchor'></a><a href='#在客户端手动做合并分块的操作'>在客户端手动做合并分块的操作</a></h1><p>这一步也是难点，相当坑，坑死人。</p>\n<p>博主的webpack配置中，由于要使用tree-shaking来省下20KB左右的打包大小，因此没有分vendor公共块出去。</p>\n<p>如果分了vendor，那么直接把上一步生成的script标签迁移到vendor块的script标签之后和app块的script标签之前，就可以保证在vue运行前执行了我们生成好的那个分块了。</p>\n<p>但是既然没有分块，所有代码都在app.js中，那么就需要延迟vue运行，以确保app.js标签后面的我们追加的script标签内容比vue先运行</p>\n<p>否则vue-router会提前发现该组件是异步组件，然后它就自己帮我们调用webpackJsonp生成好async script标签了，这本来就是本文要避免的。</p>\n<h2><a href='#延迟app根实例的产生' id='延迟app根实例的产生' class='anchor'></a><a href='#延迟app根实例的产生'>延迟app根实例的产生</a></h2><pre class=\"hljs\"><code>const <span class=\"hljs-attr\">isProd</span> = process.env.<span class=\"hljs-attr\">NODE_ENV</span> === 'production'\n\nconst <span class=\"hljs-attr\">appOption</span> = {\n  router,\n  store,\n  ...App\n}\n\n<span class=\"hljs-keyword\">let</span> app\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-attr\">isProd</span> === <span class=\"hljs-literal\">false</span>) {\n  <span class=\"hljs-attr\">app</span> = new Vue(appOption)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">preFetchComponent</span> = [\n  Sidebar\n]\n\nexport { app, appOption, router, store, preFetchComponent, isProd }\n</code></pre><h3><a href='#在服务端生成根实例' id='在服务端生成根实例' class='anchor'></a><a href='#在服务端生成根实例'>在服务端生成根实例</a></h3><p>本文和服务端入口文件没关系，直接生成</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, preFetchComponent, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> isDev = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>\n\n<span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n</code></pre><h3><a href='#延迟客户端根实例的产生与挂载' id='延迟客户端根实例的产生与挂载' class='anchor'></a><a href='#延迟客户端根实例的产生与挂载'>延迟客户端根实例的产生与挂载</a></h3><pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> { app, appOption, router, store, isProd } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./main'</span>\n\n<span class=\"hljs-keyword\">const</span> callback = isProd ? setTimeout : router.onReady.bind(router)\n<span class=\"hljs-keyword\">if</span> (isProd) {\n  store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">true</span>\n}\n\ncallback(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (isProd) store.state.isLoadingAsyncComponent = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">let</span> realApp = isProd ? <span class=\"hljs-keyword\">new</span> Vue(appOption) : app\n\n  <span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__.route.hash = <span class=\"hljs-built_in\">window</span>.location.hash\n  store.replaceState(<span class=\"hljs-built_in\">window</span>.__INITIAL_STATE__)\n  realApp.$mount(<span class=\"hljs-string\">'#app'</span>)\n})\n</code></pre><p>router.onReady为vue-router 2.2.0的新增方法，在客户端异步组件加载完时触发，我们只在开发环境调用这个回调，用来确保客户端hydrate出来的HTML和SSR出来的一致。</p>\n<p>到了正式环境，直接用setTimeout来延迟加载了。</p>\n<h1><a href='#简单修改异步组件' id='简单修改异步组件' class='anchor'></a><a href='#简单修改异步组件'>简单修改异步组件</a></h1><h2><a href='#修改全局状态' id='修改全局状态' class='anchor'></a><a href='#修改全局状态'>修改全局状态</a></h2><p>添加如下的状态</p>\n<pre class=\"hljs\"><code><span class=\"hljs-attr\">isLoadingAsyncComponent:</span> <span class=\"hljs-literal\">false</span>\n</code></pre><h2><a href='#对应修改异步组件' id='对应修改异步组件' class='anchor'></a><a href='#对应修改异步组件'>对应修改异步组件</a></h2><pre class=\"hljs\"><code>  preFetch: fetchAchieves,\n  beforeMount () {\n    <span class=\"hljs-keyword\">this</span>.isLoadingAsyncComponent &amp;&amp; <span class=\"hljs-keyword\">this</span>.$root._isMounted &amp;&amp; fetchAchieves(<span class=\"hljs-keyword\">this</span>.$store, <span class=\"hljs-keyword\">this</span>.$route)\n  }\n</code></pre><p>不用这个状态来标志的话，客户端组件会在SSR数据已经存在的情况下再次获取组件，造成浪费</p>\n<h2><a href='#选择性优化客户端的router钩子' id='选择性优化客户端的router钩子' class='anchor'></a><a href='#选择性优化客户端的router钩子'>选择性优化客户端的router钩子</a></h2><p>如果你使用了router的两个钩子，建议做如下处理</p>\n<h3><a href='#router.aftereach' id='router.aftereach' class='anchor'></a><a href='#router.aftereach'>router.afterEach</a></h3><pre class=\"hljs\"><code>router.afterEach((<span class=\"hljs-keyword\">to</span>, <span class=\"hljs-keyword\">from</span>) =&gt; {\n  <span class=\"hljs-comment\">// should delay it to get the correct title generated by vue-meta</span>\n  <span class=\"hljs-keyword\">from</span>.<span class=\"hljs-built_in\">name</span> &amp;&amp; clientGoogleAnalyse(<span class=\"hljs-keyword\">to</span>.path)\n})\n</code></pre><p>通过本文的延迟app挂载这种方法时，router.afterEach会在初始时被vue-router触发，博主猜测应当是vue处理异步组件后自行触发的，因此需要一个标志来避免触发。</p>\n<p>由于本博客所有路由都是具名路由，而这种触发时from.name会为null，据此可以做过滤</p>\n<h3><a href='#router.beforeeach' id='router.beforeeach' class='anchor'></a><a href='#router.beforeeach'>router.beforeEach</a></h3><p>异步组件的存在，导致数据获取的流程发生了变化，首先是异步组件被加载好，再触发异步组件的preFetch钩子进行数据获取，最后根据数据是否正常判断是否该进入路由。</p>\n<p>如果不按这个流程来，会出现新路由数据尚未获取到就进入了该组件的情况，当数据拿到时会发生一次闪屏，不仅无法控制路由，而且用户体验非常差。</p>\n<p>读者可以参考如下的数据获取流程</p>\n<pre class=\"hljs\"><code>router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 仅hash变化时，直接进入路由</span>\n  <span class=\"hljs-keyword\">if</span> (to.path === <span class=\"hljs-keyword\">from</span>.path &amp;&amp; to.hash !== <span class=\"hljs-keyword\">from</span>.hash) {\n    <span class=\"hljs-keyword\">return</span> next()\n  }\n\n  <span class=\"hljs-comment\">// Loading组件开始加载</span>\n  <span class=\"hljs-keyword\">let</span> loadingPromise = store.dispatch(<span class=\"hljs-string\">'START_LOADING'</span>)\n  <span class=\"hljs-keyword\">let</span> endLoadingCallback = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> loadingPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">interval</span> =&gt;</span> {\n      clearInterval(interval)\n      store.dispatch(<span class=\"hljs-string\">'SET_PROGRESS'</span>, <span class=\"hljs-number\">100</span>)\n      next()\n    })\n  }\n\n  <span class=\"hljs-comment\">// 根据本博客的路由定义，一定有一个组件能够被匹配到</span>\n  <span class=\"hljs-keyword\">let</span> component = router.getMatchedComponents(to.fullPath)[<span class=\"hljs-number\">0</span>]\n\n  <span class=\"hljs-comment\">// 如果是一个异步组件，我们手动resolve它，再接着调用它的preFetch接口，这样可以避免闪屏</span>\n  <span class=\"hljs-comment\">// 异步组件也是一个函数，但是它没有options这个值，可以据此做条件判断</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> component === <span class=\"hljs-string\">'function'</span> &amp;&amp; !component.options) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// 一个resolve函数</span>\n      <span class=\"hljs-keyword\">const</span> _resolve = <span class=\"hljs-function\"><span class=\"hljs-params\">realComponent</span> =&gt;</span> {\n        resolve(realComponent)\n      }\n      <span class=\"hljs-comment\">// 对普通异步组件来说，它会在第一层中被直接resolve，因此直接将resolve函数传给它调用</span>\n      <span class=\"hljs-keyword\">let</span> res = component(_resolve)\n      <span class=\"hljs-comment\">// 对工厂模式的组件生成函数来说，它第一层中产生的只是工厂函数，组件是在第二步中产生的</span>\n      <span class=\"hljs-comment\">// 这种工厂函数是thenable的，因此将resolve函数用then传给第二层调用</span>\n      <span class=\"hljs-keyword\">if</span> (res &amp;&amp; res.then) {\n        res.then(_resolve)\n      }\n    }).then(<span class=\"hljs-function\"><span class=\"hljs-params\">component</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// 这里的component就是异步组件加载完毕后的真实组件了，开始调用数据获取函数</span>\n      <span class=\"hljs-keyword\">return</span> letsGo(component, store, to, endLoadingCallback)\n    })\n  }\n  <span class=\"hljs-comment\">// 调用数据获取函数</span>\n  letsGo(component, store, to, endLoadingCallback)\n})\n\n<span class=\"hljs-comment\">// 数据获取函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letsGo</span> (<span class=\"hljs-params\">component, store, to, endLoadingCallback</span>) </span>{\n  <span class=\"hljs-comment\">// 如果preFetch钩子存在，调用这个钩子，并将endLoadingCallback这个停止loading并进入路由的回调传给它</span>\n  <span class=\"hljs-keyword\">if</span> (component &amp;&amp; component.preFetch) {\n    <span class=\"hljs-keyword\">return</span> component.preFetch(store, to, endLoadingCallback).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-built_in\">Date</span>.now().toLocaleString(), err)\n    })\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 如果preFetch钩子不存在，说明这是一个静态页面，直接导航进入。</span>\n    endLoadingCallback()\n  }\n}\n</code></pre><p>这里给出preFetch的模板</p>\n<pre class=\"hljs\"><code><span class=\"hljs-selector-tag\">function</span> <span class=\"hljs-selector-tag\">preFetch</span> (store, { <span class=\"hljs-attribute\">path</span>: pathName, params, query }, <span class=\"hljs-selector-tag\">callback</span>) {\n  <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">store</span><span class=\"hljs-selector-class\">.dispatch</span>(<span class=\"hljs-string\">'FETCH_TAGS'</span>, {\n    <span class=\"hljs-attribute\">model</span>: <span class=\"hljs-string\">'post'</span>,\n    <span class=\"hljs-attribute\">query</span>: {\n      <span class=\"hljs-attribute\">conditions</span>: {\n        <span class=\"hljs-attribute\">type</span>: <span class=\"hljs-string\">'post'</span>,\n        <span class=\"hljs-attribute\">isPublic</span>: true\n      },\n      <span class=\"hljs-attribute\">select</span>: {\n        <span class=\"hljs-attribute\">_id</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attribute\">tags</span>: <span class=\"hljs-number\">1</span>\n      }\n    },\n    callback\n  })\n}\n</code></pre><p>这种模板既能让它在SSR中被调用，又可以在客户端中被路由权限控制调用，十分有用</p>\n<p>最后，在action中手动调用callback这个参数，即可停止loading并进入路由了</p>\n<h1><a href='#结语' id='结语' class='anchor'></a><a href='#结语'>结语</a></h1><p>本文介绍的这种所有路由全部按需分块加载并完全不影响首屏速度的策略，是首屏优化中极少有人关注的。</p>\n<p>然而，它的效果十分强大，按这种策略优化首屏之后，配合SSR的SPA可以任意扩展体积与功能，并且首屏渲染将和SPA只有首屏页面时几乎一模一样。例如，本博客现在就可以毫无顾忌地开始做搜索页面了。</p>\n<p>最后，非常明显的是，本文的策略会带来一个问题，即非首屏的访问速度将会被拖慢，因为需要浏览器自行发起jsonp请求。解决办法其实也比较简单，只需要在首屏加载完成后让浏览器自行请求并缓存好对应的分块即可，这要求我们在构建时就必须得知分块的路径，并且需要搭配一个超强的请求拦截器，这也正是博主下一篇文章的内容。</p>\n"
}]